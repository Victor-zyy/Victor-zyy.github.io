[{"content":"operator new/delete introduction In the last sections, we\u0026rsquo;ve already talked about new and delete. new expression is divided three parts\nallocate memory using operator new static_cast ctor and the delete expression is divided two parts\ndtor operator delete to release memory However, expression is not allowed to override, but operator new and operator delete are allowed to override inside class or outside class(global).\noverride ::operator new/::delete/::new[]/::delete[] here is an example to override the global operator new/delete function\nvoid *myalloc(size_t size) { return malloc(size); } void myfree(void *ptr) { return free(ptr); } // they cannot be declared in a namespace void* operator new(size_t size){ cout \u0026lt;\u0026lt; \u0026#34;global new()\\n\u0026#34;; return myalloc(size); } void* operator new[](size_t size){ cout \u0026lt;\u0026lt; \u0026#34;global new[]()\\n\u0026#34;; return myalloc(size); } void operator delete(void *ptr){ cout \u0026lt;\u0026lt; \u0026#34;global delete() \\n\u0026#34;; return free(ptr); } void operator delete[](void *ptr){ cout \u0026lt;\u0026lt; \u0026#34;global delete[]() \\n\u0026#34;; return free(ptr); } There is one thing to note that, replacement function can not be declared inline. Actually the parameter is passed by the compiler, you don\u0026rsquo;t have to calculate the size.\noverride member operator new/delete class Foo{ public: void *operator new[](size_t); void operator delete[](void*, size_t); // the second arg is optional }; Foo *p = new Foo[N]; // can be converted to try { void *mem = operator new(sizeof(Foo) * N + 4); p = static_cast\u0026lt;Foo*\u0026gt;(mem); p-\u0026gt;Foo:Foo(); // N times } delete[] p; // can be converted to p-\u0026gt;~Foo(); // N times operator delete(p); The memory operator new/delete override example is shown below\nclass Foo { public: int _id; long _data; string _str; public: Foo() :_id(0) { cout \u0026lt;\u0026lt;\u0026#34;default ctor this \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; _id \u0026lt;\u0026lt; endl; } Foo(int i) : _id(i) { cout \u0026lt;\u0026lt; \u0026#34;ctor this \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; _id \u0026lt;\u0026lt; endl;} ~Foo() { cout \u0026lt;\u0026lt; \u0026#34;dtor this \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; _id \u0026lt;\u0026lt; endl; } static void *operator new(size_t size); static void *operator new[](size_t size); static void operator delete(void *pdead, size_t size); static void operator delete[](void *pdead, size_t size); }; void* Foo::operator new(size_t size){ Foo* p = (Foo*)malloc(size); return p; } void* Foo::operator new[](size_t size){ Foo* p = (Foo*)malloc(size); cout \u0026lt;\u0026lt; \u0026#34;size new[] \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; return p; } void Foo::operator delete(void *pdead, size_t size){ free(pdead); } void Foo::operator delete[](void *pdead, size_t size){ free(pdead); } int main(){ cout \u0026lt;\u0026lt; sizeof(Foo) \u0026lt;\u0026lt; endl; Foo *p = new Foo(7); delete p; Foo *parray = new Foo[5]; delete []parray; } After I run this program it will print out something like this below.\n48 ctor this 0x5586af6376c0id=7 dtor this 0x5586af6376c0id=7 size new[] 248 default ctor this 0x5586af637708id=0 default ctor this 0x5586af637738id=0 default ctor this 0x5586af637768id=0 default ctor this 0x5586af637798id=0 default ctor this 0x5586af6377c8id=0 dtor this 0x5586af6377c8id=0 dtor this 0x5586af637798id=0 dtor this 0x5586af637768id=0 dtor this 0x5586af637738id=0 dtor this 0x5586af637708id=0 The sizefo Foo is 48 bytes, but when I allocate 5 object with new[] it turns out that it will allocate more 8 bytes that I think, That is the compiler use this 8 bytes to store the size of the array which can ctor quickly in 64bit machine.\nnew/delete pair In such a condition, if we use new[] to allocate memory, but delete without [], what will happened? Here is the example to illustrate.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; void *myalloc(size_t size) { return malloc(size); } void myfree(void *ptr) { return free(ptr); } // they cannot be declared in a namespace void* operator new(size_t size){ cout \u0026lt;\u0026lt; \u0026#34;global new() \u0026#34; \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; return myalloc(size); } void* operator new[](size_t size){ cout \u0026lt;\u0026lt; \u0026#34;global new[]()\\n\u0026#34;; return myalloc(size); } void operator delete(void *ptr){ cout \u0026lt;\u0026lt; \u0026#34;global delete() \\n\u0026#34;; myfree(ptr); } void operator delete[](void *ptr){ cout \u0026lt;\u0026lt; \u0026#34;global delete[]() \\n\u0026#34;; myfree(ptr); } class A{ public: int data; public: ~A() { cout \u0026lt;\u0026lt; \u0026#34;dtor A \u0026#34; \u0026lt;\u0026lt;endl; } }; int main(){ A *pa = new A[4]; pa-\u0026gt;data = 4; delete pa; } The result is that it will core dumped. But what happened in detail.\n$./a.out global new[]() dtor A global delete() segmentation fault (core dumped) using valgrind to check ==692147== 24 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==692147== at 0x484A2F3: operator new[](unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so) ==692147== by 0x1093B1: main (new.cc:34) ==692147== ==692147== LEAK SUMMARY: ==692147== definitely lost: 24 bytes in 1 blocks ==692147== indirectly lost: 0 bytes in 0 blocks ==692147== possibly lost: 0 bytes in 0 blocks ==692147== still reachable: 0 bytes in 0 blocks ==692147== suppressed: 0 bytes in 0 blocks We should use new/delete in pair.\nplacement new/delete We can override class member operator new() with lots of versions, the beforhand of this overridding is that every declaration must have special argument list, and the first argument is size_t, when happens new(), and the argument in the () is placement arguments. Foo *pf = new(300, \u0026lsquo;c\u0026rsquo;) Foo; Also, we can override class member operator delete() with lots of versions, and it will not be called by delete until throw an exception in ctor. It is mainly used in measure memory in object.\nclass Bad{}; class Foo{ public: Foo() { cout \u0026lt;\u0026lt; \u0026#34;Foo::Foo()\u0026#34; \u0026lt;\u0026lt; endl; } Foo(int) { cout \u0026lt;\u0026lt; \u0026#34;Foo::Foo(int)\u0026#34; \u0026lt;\u0026lt;endl; throw Bad(); } void *operator new(size_t size){ return malloc(size); // ordinary malloc } void *operator new(size_t size, void *start){ return start; } void *operator new(size_t size, long extra){ return malloc(size + extra); } void *operator new(size_t size, long extra, char init){ return malloc(size + extra); } // ordinary delete void operator delete(void *pdead, size_t size){ cout \u0026lt;\u0026lt; \u0026#34;operator delete(void , size_t) \u0026#34; \u0026lt;\u0026lt; endl; } void operator delete(void *pdead, void *){ cout \u0026lt;\u0026lt; \u0026#34;operator delete(void , void) \u0026#34; \u0026lt;\u0026lt; endl; } void operator delete(void *pdead, long){ cout \u0026lt;\u0026lt; \u0026#34;operator delete(void , long) \u0026#34; \u0026lt;\u0026lt; endl; } void operator delete(void *pdead, long, char){ cout \u0026lt;\u0026lt; \u0026#34;operator delete(void , long, char)\u0026#34; \u0026lt;\u0026lt; endl; } private: int m_; }; If you give up dealing with ctor exception, there is no need to correspond new/delete one by one. But in my version of g++(13.0) there is no placement operator called.\nFoo::Foo() Foo::Foo(int) terminate called after throwing an instance of \u0026#39;Bad\u0026#39; aborted (core dumped) basic_string Basic_string use member placement operator new to store reference counting.\ntemplate \u0026lt;\u0026gt; class basic_string{ private: struct Rep{ void release() { if( -- ref== 0) delete this; } static void *operator new(size_t, size_t); static void operator delete(void *); static Rep* create(size_t); }; }; template\u0026lt;class charT, class traits, class Allocator\u0026gt; inline basic_string\u0026lt;charT, traits, Allocator\u0026gt;::Rep* basic_string \u0026lt;charT, traits, Allocator\u0026gt;::Rep:: create(size_t extra) { extra = frob_size(extra + 1); Rep * p = new(extra) Rep; return p; } ... operator new(size_t s, size_t extra){ return Allocator::allocate(s + extra * sizeof(charT)); } ","permalink":"http://localhost:1313/posts/c++_basic/6_new_delete/","summary":"\u003ch2 id=\"operator-new-delete\"\u003eoperator new/delete\u003c/h2\u003e\n\u003ch3 id=\"introduction\"\u003eintroduction\u003c/h3\u003e\n\u003cp\u003eIn the last sections, we\u0026rsquo;ve already talked about new and delete. new expression is divided three parts\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eallocate memory using operator new\u003c/li\u003e\n\u003cli\u003estatic_cast\u003c/li\u003e\n\u003cli\u003ector\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eand the delete expression is divided two parts\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edtor\u003c/li\u003e\n\u003cli\u003eoperator delete to release memory\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, expression is not allowed to override, but operator new and operator delete are allowed to override inside class or outside class(global).\u003c/p\u003e\n\u003ch3 id=\"override-operator-new-delete-new-delete\"\u003eoverride ::operator new/::delete/::new[]/::delete[]\u003c/h3\u003e\n\u003cp\u003ehere is an example to override the global operator new/delete function\u003c/p\u003e","title":"6-new-delete-object-model-cpp"},{"content":"vptr and vtbl outline Let\u0026rsquo;s use an example to illustrate the c++ object model (aka vptr and vbtl).\nclass A{ public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; } class B: public A{ public: virtual void vfunc1(); void func2(); private: int m_data3; } class C: public B{ public: virtual void vfunc1(); void func1(); private: int m_data1, m_data4; } If we create an object, the sizeof the object is member data variable. But if the class has at least one virtual function it will add another variable called vptr in object. In this example above, the inheritance of class and memory is shown below. In each class B and class C, all override the virtual function 1, so each one is really different in memory. But B and C inherit from A, so all objects of B and C have vbtl entry pointing to A::func2. The picture shown above is really clear to see that. The vptr in another side means that inheritance not only inherits data but also inherits access of function calls.\ndynamic binding The dynamic binding or polymorphism is effective when meeting three conditions\npinter use satisfy up-cast (aka pointed to derived class) virtual function And the final call of the dynamic binding is like, the compiler will do to generate code like this when the dynamic binding effects. n is computed by compiler and p is pointer.\n(*(p-\u0026gt;vptr)[n])(p); // or (* p-\u0026gt;vptr[n] )(p); Here is the example to illustrate that. Conditions, C derived from B, B derived from A.\nB b; A a = (A)b; a.vfunc1(); // static binding in asm tail / call instruction A *pa = new B; pa-\u0026gt;vfunc1(); // dynamic binding in asm using vbtl // (* pa-\u0026gt;vptr[n])(pa) Using object to call virtual function is not dynamic binding.\nconst const object non-const object const member funcitons (guarantee data members + + non-const member functions - + (cannot guarantee0 Note, when the non-const and const member functions occur at the same time in the class, the const object cannot access the non-const member function only const member function.\nexample in STL charT operator [](size_type pos) const { ... } reference operator [](size_type pos) const { ... } s[5] = \u0026lsquo;A\u0026rsquo; may trigger of COW(copy on write), so we have to handle that. The basic_string adopts the shared-method design pattern, which means sometimes you may don\u0026rsquo;t have to change the value of string, if you do so when offer that and copy another one for you. This is reference counting method.\n","permalink":"http://localhost:1313/posts/c++_basic/5_object_model_virtual/","summary":"\u003ch2 id=\"vptr-and-vtbl\"\u003evptr and vtbl\u003c/h2\u003e\n\u003ch3 id=\"outline\"\u003eoutline\u003c/h3\u003e\n\u003cp\u003eLet\u0026rsquo;s use an example to illustrate the c++ object model (aka vptr and vbtl).\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eA\u003c/span\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003evirtual\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e vfunc1();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003evirtual\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evfunc2\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efunc1\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efunc2\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m_data1, m_data2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eB\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e A{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003evirtual\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e vfunc1();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efunc2\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m_data3;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eC\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e B{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003evirtual\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e vfunc1();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efunc1\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m_data1, m_data4;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf we create an object, the sizeof the object is member data variable. But if the class has at least one virtual function it will add another variable called vptr in object.\nIn this example above, the inheritance of class and memory is shown below.\n\u003cimg loading=\"lazy\" src=\"/c_plus_plus/images/5_vptr_vbtl.png\"\u003e\nIn each class B and class C, all override the virtual function 1, so each one is really different in memory. But B and C inherit from A, so all objects of B and C have vbtl entry pointing to A::func2. The picture shown above is really clear to see that.\nThe vptr in another side means that inheritance not only inherits data but also inherits access of function calls.\u003c/p\u003e","title":"5-vptr-vbtl-object-model-cpp"},{"content":"auto (since c++ 11) Using this keyword in c++ since c11, the compiler can deduce in the compilling time. If the typename is too long to write you can use it and let compiler to deduce.\nlist\u0026lt;string\u0026gt; c; list\u0026lt;string\u0026gt;::iterator ite; ite = find(c.begin(), c.end(), target); auto ite = find(c.begin(), c.end(), target); range-base for( since c++11) In normal c++, we can use for-loop of type iterator or container.size to iterate the container. In c++11, it provides us a new for-loop.\nfor( decl : coll) { } The first must be declaration and the second one must be a container. We can use in this example.\nvector\u0026lt;double\u0026gt; vec; for(auto elem : vec ) // pass be value { cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; endl; } for(auto \u0026amp;elem : vec ) // pass be reference { elem *= 2; // you can change cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; endl; } When passing by value it needs to copy for every element, but passing by reference is more efficient. And you can change the actual value of elem in the vector.\nReference The reference in bottom is a smart pointer than pointer, but it will pretend to show the same thing as value, which means that the size equals and the address equals.\nsizeof(reference) ==sizeof( value) \u0026amp;reference == \u0026amp;value Usage Usually, reference is used in argument passing not in the declaration types. passing by value and passing by reference can be use in the same way only differs in function declaration.And the reference is more efficient. Passing by pointer is confused with the reference, and reference is pointer at some point.\nvoid func1(Cls* pobj) { pobj-\u0026gt;.... } void func1(Cls\u0026amp; pobj) { pobj.... } void func1(Cls pobj) { pobj.... } Cls obj; func1(\u0026amp;obj); func2(obj); func3(obj); signature: without return type, the function name and argument and const suffix including. if you define two functions like that it will cause compiler ambiguity.\ndouble imag(const double\u0026amp; im) {} double imag(const double im) {} ","permalink":"http://localhost:1313/posts/c++_basic/4_syntactic_sugar/","summary":"\u003ch2 id=\"auto--since-c-plus-plus-11\"\u003eauto (since c++ 11)\u003c/h2\u003e\n\u003cp\u003eUsing this keyword in c++ since c11, the compiler can deduce in the compilling time. If the typename is too long to write you can use it and let compiler to deduce.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elist\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003estring\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e c;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elist\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003estring\u003cspan style=\"color:#f92672\"\u003e\u0026gt;::\u003c/span\u003eiterator ite;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eite \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e find(c.begin(), c.end(), target);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e ite \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e find(c.begin(), c.end(), target);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"range-base-for--since-c-plus-plus-11\"\u003erange-base for( since c++11)\u003c/h2\u003e\n\u003cp\u003eIn normal c++, we can use for-loop of type iterator or container.size to iterate the container. In c++11, it provides us a new for-loop.\u003c/p\u003e","title":"4-syntactic-sugar-object-model-cpp"},{"content":"Template The template will be compiled successfully, but when called by user, it will be compiled again which might cause error. And the most important thing is operator overload function.\ntemplate class template\u0026lt;typename T\u0026gt; class complex { private: T re, ra; } .... complex\u0026lt;int\u0026gt; c1; complex\u0026lt;double\u0026gt; c1; When the compiler sees the Complex\u0026lt;int\u0026gt; or Complex\u0026lt;double\u0026gt; it will generate two slices of Complex has different type. This is kind of wasteful of memory but it\u0026rsquo;s necessary.\ntemplate function stone r1(2,3), r2(2,0), r3; r3 = min(r1, r2); --\u0026gt; template \u0026lt;class T\u0026gt; inline const T\u0026amp; min(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? a : b; } --\u0026gt; class stone { public: ... bool operator \u0026lt; (const stone\u0026amp; t2) { return _weight \u0026lt; t2._weight; } private: double _weight; double _height; }; The compiler will do argument deduction to function template, which we don\u0026rsquo;t have to add \u0026lt;int\u0026gt; or \u0026lt;stone\u0026gt; after the min function. After that, the min function will call the operator \u0026lt; function. So the class designer must overload this function.\nThe compiler will compile the template, when you call this template function it will compile the code again.\nmember template in a simple way to clarify that a template in template.\ntemplate\u0026lt;class T1, class T2\u0026gt; struct pair{ typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair() :first(T1()), second(T2()) {} pair(const T1\u0026amp; a, const T2\u0026amp; b) :first(a), second(b) {} // ctor overload template\u0026lt;class U1, class U2\u0026gt; pair(const pair\u0026lt;U1, U2\u0026gt;\u0026amp; p) : first(p.first), second(p.second) {}; }; Here is an example like we have two types of class and their derived classes. The question is that can we assign to it ?\nclass Base1 {}; class Derived1: public Base1{}; class Base2 {}; class Derived2: public Base2{}; //T1 T2 pair\u0026lt;Derived1, Derived2\u0026gt; p; pair\u0026lt;Base1, Base2\u0026gt; p2(p); //T1 T2 U1 U2 pair\u0026lt;Base1, Base2\u0026gt; p2(pair\u0026lt;Derived1, Derived2\u0026gt;()); pair(const pair\u0026lt;U1, U2\u0026gt;\u0026amp; p) : first(p.first), second(p.second) {} indicates that U1 is assigned to T1 also for U2 and T2. Can the assignment succeed or not? Let\u0026rsquo;s use an example in life. The sparrow derived from bird, and sparrow is a bird (inheritance). Fine! From this example we know that derived class can be assigned to base class which means the derived class can be converted to base class. But on the opposite it\u0026rsquo;s not allowed.\nThe reason in STL using member template is to make the STL more elastic.\nIn STL member template template\u0026lt;typename _Tp\u0026gt; class shared_ptr : public __shared_ptr\u0026lt;_Tp\u0026gt; { template\u0026lt;typename _Tp1\u0026gt; explicit shared_ptr(_Tp1 *__p) :__shared_ptr\u0026lt;_Tp\u0026gt;(__p) {} }; // smart pointer Base *ptr = new Derived1; // up-cast shared_ptr\u0026lt;Base\u0026gt; sptr(new Derived); // simulate up-cast Base class pointer can point to Derived class which is easy and rational to understand. So the shared_ptr must have this attribute so member template matters.\nSpecialization template specialization (full specialization) The template specialization is used for special design of template, we all know that the template is used for generalization. Okay, here is an example!\ntemplate\u0026lt;class Key\u0026gt; struct hash{}; template\u0026lt;\u0026gt; struct hash\u0026lt;char\u0026gt;{ size_t operator() (char x) const { return x; } } template\u0026lt;\u0026gt; struct hash\u0026lt;int\u0026gt;{ size_t operator() (int x) const { return x; } } template\u0026lt;\u0026gt; struct hash\u0026lt;long\u0026gt;{ size_t operator() (long x) const { return x; } } cout \u0026lt;\u0026lt; hash\u0026lt;long\u0026gt;()(100); In the example above, we have not only generalization but also specialization, when we instance a new object passing type like( char, int, long), the compiler will compile the specialization template related, if passed other types, the compiler will use the generalization template. It\u0026rsquo;s useful in some cases.\npartial specialization The partial specialization includes two types like numeric partial specialization and scope partial specialization. Firstly let\u0026rsquo;s talk about the numeric partial specialization. Here is the example.\ntemplate\u0026lt;typename T, typename Alloc=...\u0026gt; class vector { } template\u0026lt;typename Alloc=...\u0026gt; class vector\u0026lt;bool, Alloc\u0026gt; { .. } template argument of the vector is two, T and Alloc, numeric partial specialization means that I use only one argument Alloc in this example. That\u0026rsquo;s beacause that we all know that to store the bool type we can use bit of char or something else, it\u0026rsquo;s not necessary to store the bool type in a generalization in case of reduce memory usage. Note, the template argument cannot be only two may be more but when you choose the numeric partial specialization you have to follow the sequences of the argument which means you cannot jump one of the two.\nAnother type of partial specialization is scope partial specialization, here is the example.\ntemplate\u0026lt;typename T\u0026gt; class C { }; template\u0026lt;typename T\u0026gt; -\u0026gt; template \u0026lt;typename U\u0026gt; class C\u0026lt;T*\u0026gt; class C\u0026lt;U*\u0026gt; { { }; }; C\u0026lt;string\u0026gt; obj1; C\u0026lt;string*\u0026gt; obj1; The scope in this example means that a pointer pointing an instance and an instance.The pointer means narrow the scope actually.\ntemplate template parameter tempate template parameter means that among the template arguments there is one template like argument.Which in my opinoin is hard to understand.Here is an example.\ntemplate\u0026lt;typename T, template \u0026lt;typename T\u0026gt; class Container \u0026gt; class XCls { private: Container\u0026lt;T\u0026gt; c; }; template\u0026lt;typename T\u0026gt; using Lst = list\u0026lt;T, allocator\u0026lt;T\u0026gt;\u0026gt;; XCLs\u0026lt;string, list\u0026gt; mylist1; // error XCLs\u0026lt;string, Lst\u0026gt; mylist2; In this example above, I wanna use linked list to store the string, so we need another argument container is template. However the template template argument needs special sanity to pass using. The container need two arguments, but the smartptr needs only one argument. Note, only in this condition, the class and typename is the same meaning.\nvariadic templates( since c++ 11) the template argument number maybe be unsure, so since c++11, a new feature comes that you can divide the template arguments into one argument and the other is one packet using the \u0026hellip;. Here is the example.\nvoid print() { } template\u0026lt;typename T, typename... Types\u0026gt; void print(const T\u0026amp; fristarg, const Types\u0026amp;... args) { cout \u0026lt;\u0026lt; firstarg \u0026lt;\u0026lt; endl; print(args...); } pack three ways to add \u0026hellip;\ntemplate argument function parameter types function arguments Don\u0026rsquo;t forget the \u0026hellip; in the template argument list and function parameters, inside of the function, if you use sizeof()\u0026hellip; you can access the number of arguments. As you can see, this example use the print recusively so you need to prepare an empty print function to end the calling.\n","permalink":"http://localhost:1313/posts/c++_basic/3_template/","summary":"\u003ch2 id=\"template\"\u003eTemplate\u003c/h2\u003e\n\u003cp\u003eThe template will be compiled successfully, but when called by user, it will be compiled again which might cause error. And the most important thing is operator overload function.\u003c/p\u003e\n\u003ch3 id=\"template-class\"\u003etemplate class\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003etypename\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecomplex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  T re, ra;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e....\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e c1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e c1;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhen the compiler sees the Complex\u0026lt;int\u0026gt; or Complex\u0026lt;double\u0026gt; it will generate two slices of Complex has different type. This is kind of wasteful of memory but it\u0026rsquo;s necessary.\u003c/p\u003e","title":"3-template-object-model-cpp"},{"content":"pointer-like classes we say pointer like classes are smart pointers. overload operator* and operator-\u0026gt; function\nsimple in class template\u0026lt;class T\u0026gt; class shared_ptr { public: T\u0026amp; operator*() const { return *px; } T* operator-\u0026gt;() const { return px; } shared_ptr(T* p) : px(p) {} private: T* px; long *pn; }; //usage example struct Foo { ... void method(void) { ... } }; shared_ptr\u0026lt;Foo\u0026gt; sp(new Foo); Foo f(*sp); sp-\u0026gt;method(); px-\u0026gt;method(); I am gonna to clarify that sp-\u0026gt;method, the sp-\u0026gt; will call the operator-\u0026gt; function, it will return the px pointer but why it will call method function. Note: remember that -\u0026gt; will never disappear when called the operator-\u0026gt; function.\niterator in STL we use linked-list as an example\ntemplate\u0026lt;class T\u0026gt; struct __list_node { void *prev; void *next; T data; }; template\u0026lt;class T, class Ref, class Ptr\u0026gt; struct __list_iterator { typedef __list_iterator\u0026lt;T, Ref, Ptr\u0026gt; self; typedef Ptr pointer; typedef Ref reference; typedef __list_node\u0026lt;T\u0026gt;* link_type; link_type node; ... reference operator*() const { return (*node).data; } pointer operator-\u0026gt;() const { return \u0026amp;(operator*()); } }; The outline of this iterator is like this. //example list\u0026lt;Foo\u0026gt;::iterator ite; *ite; //get the Foo object ite-\u0026gt;method(); Let\u0026rsquo;s clarify this example, the user didn\u0026rsquo;t know prev and next, the only know the Foo object, which means that the operator* and operator-\u0026gt; much behaves like linked list Foo object. So ite-\u0026gt;method is the same as (*ite).method, and \u0026amp;(*ite)-\u0026gt;method\nNo matter how smarter the smart_ptr is , the operator* and operator-\u0026gt; didn\u0026rsquo;t change except for iterator which has to resolve the real object node like Foo object.\nfunction-like classes overload operator() function\nexample Example:\ntemplate \u0026lt;class T1, class T2\u0026gt; struct pair{ typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair() :first(T1()), second(T2()) {} pair(const T1\u0026amp; a, const T2\u0026amp; b) :first(a), second(b) {} }; template \u0026lt;class T\u0026gt; struct identiy .. { const T\u0026amp; operator() (const T\u0026amp; x) const { return x; } }; template \u0026lt;class Pair\u0026gt; struct select1st .. { const typename Pair::first_type\u0026amp; operator() (const Pair\u0026amp; x) const { return x.first; } }; template \u0026lt;class Pair\u0026gt; struct select2nd .. { const typename Pair::second_type\u0026amp; operator() (const Pair\u0026amp; x) const { return x.second; } }; Note: The Pair is not a type in template quote line, it is just a reminder to let the caller to pass the Pair class. Note: typename inside a struct is really a type not a random name. They all inherit from unary_function\ntemplate \u0026lt;class T\u0026gt; struct identiy : public unary_function\u0026lt;T,T\u0026gt; { const T\u0026amp; operator() (const T\u0026amp; x) const { return x; } }; template \u0026lt;class Pair\u0026gt; struct select1st : public unary_function\u0026lt;Pair, typename Pair::first_type\u0026gt;{ const typename Pair::first_type\u0026amp; operator() (const Pair\u0026amp; x) const { return x.first; } }; template \u0026lt;class Pair\u0026gt; struct select2nd : public unary_function\u0026lt;Pair, typename Pair::second_type\u0026gt;{ const typename Pair::second_type\u0026amp; operator() (const Pair\u0026amp; x) const { return x.second; } }; function-like class in STL template \u0026lt;class T\u0026gt; struct plus : public binary_function\u0026lt;T, T, T\u0026gt; { T operator() (const T\u0026amp; x, const T\u0026amp; y) const { return x + y ; } }; template \u0026lt;class T\u0026gt; struct minus : public binary_function\u0026lt;T, T, T\u0026gt; { T operator() (const T\u0026amp; x, const T\u0026amp; y) const { return x - y ; } }; template \u0026lt;class T\u0026gt; struct equal_to : public binary_function\u0026lt;T, T, bool\u0026gt; { bool operator() (const T\u0026amp; x, const T\u0026amp; y) const { return x == y ; } }; template \u0026lt;class T\u0026gt; struct less : public binary_function\u0026lt;T, T, bool\u0026gt; { bool operator() (const T\u0026amp; x, const T\u0026amp; y) const { return x \u0026lt; y ; } }; base class in function like class template \u0026lt;class Arg, class Result\u0026gt; struct unary_function { typedef Arg argument_type; typedef Result result_type; }; template \u0026lt;class Arg1, class Arg2, class Result\u0026gt; struct binary_function { typedef Arg1 first_argument_type; typedef Arg2 second_argument_type; typedef Result result_type; }; Actually there are only typedefs in the struct, in theory there may be size 0 in memory, but size probably equals to 1.\n","permalink":"http://localhost:1313/posts/c++_basic/2_special_classes/","summary":"\u003ch2 id=\"pointer-like-classes\"\u003epointer-like classes\u003c/h2\u003e\n\u003cp\u003ewe say pointer like classes are smart pointers.\noverload operator* and operator-\u0026gt; function\u003c/p\u003e\n\u003ch3 id=\"simple-in-class\"\u003esimple in class\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etemplate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eT\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eshared_ptr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   T\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003epx; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   T\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e { \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e px; }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   shared_ptr(T\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e p) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e px(p) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   T\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e px;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e   \u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003epn;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e//usage example\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e method(\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e) { ... }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eshared_ptr\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eFoo\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e sp(\u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e Foo);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eFoo \u003cspan style=\"color:#a6e22e\"\u003ef\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003esp);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esp\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003emethod();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epx\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003emethod();\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI am gonna to clarify that \u003cstrong\u003esp-\u0026gt;method\u003c/strong\u003e, the sp-\u0026gt; will call the operator-\u0026gt; function, it will return the px pointer but why it will call method function. Note: remember that -\u0026gt; will never disappear when called the operator-\u0026gt; function.\u003c/p\u003e","title":"2-special-class-object-model-cpp"},{"content":"conversion function form: operator typename()\nclass Fraction { public: Fraction(int num, int den=1) : m_numerator(num), m_denominator(den) {} operator double() const{ return (double) (m_numerator / m_denominator); } private: int m_numerator; //fenzi int m_denominator;// fenmu }; Fraction f(3,5); double d = 4 + f; The conversion function is aimed to let compiler know. When the compiler tries to compile the line double d = 4 + f; it will see if operator + (double, Fraction) is defined, or whether f is able to convert to double. Finally, the compiler will try the latter one, convert f to double use the operator double() function in Fraction. Actually you can write many conversion function as long as they are meaningful to the user.\nnon-explicit-one-argument-ctor explicit keyword This means that Fraction function only needs one passing argument but actually it has two parameters. That\u0026rsquo;s because Fraction given a int number is meaningful when den=1 as a default argument.\nclass Fraction { public: Fraction(int num, int den=1) : m_numerator(num), m_denominator(den) {} Fraction operator+ (const Fraction\u0026amp; f){ return Fraction(...); } private: int m_numerator; //fenzi int m_denominator;// fenmu }; Fraction f(3,5); Fraction d = f + 4; Fraction d = f + 4; The compiler will call non-explicit-one-argument ctor to convet 4 to Fraction(4,1). And we have operator+ overload function so Fraction adds a Fraction is ok to compile even if we don\u0026rsquo;t actually fully define this function.\nThe non-explicit ctor is the opposite of conversion function, like if you use conversion function you convert this type to another type, if you use non-explicit ctor , you convert other type to this type(ctor).\nConflict Btw, something ambiguous might happen when conflicts between conversion function and non-explicit ctor.\nclass Fraction { public: Fraction(int num, int den=1) : m_numerator(num), m_denominator(den) {} operator double() const { return (double) ( m_numerator / m_denominator); } Fraction operator+ (const Fraction\u0026amp; f){ return Fraction(....); } private: int m_numerator; //fenzi int m_denominator;// fenmu }; Fraction f(3,5); Fraction d = f + 4; // which will cause ambiguous explicit.cc:21:18: error: ambiguous overload for ‘operator+’ (operand types are ‘Fraction’ and ‘int’) 21 | Fraction d = f + 4; // which will cause ambiguous | ~ ^ ~ | | | | | int | Fraction explicit.cc:21:18: note: candidate: ‘operator+(double, int)’ (built-in) 21 | Fraction d = f + 4; // which will cause ambiguous | ~~^~~ explicit.cc:12:12: note: candidate: ‘Fraction Fraction::operator+(const Fraction\u0026amp;)’ 12 | Fraction operator+ (const Fraction\u0026amp; f){ | ^~~~~~~~ The ambiguity exists in that overload operator+ function. operator+(double , int) and operator+(const Fraction\u0026amp; f);\nexplicit The explicit means that you have to call ctor explicitly don\u0026rsquo;t do implicitly in compile time.\nclass Fraction { public: explicit Fraction(int num, int den=1) : m_numerator(num), m_denominator(den) {} operator double() const { return (double) ( m_numerator / m_denominator); } Fraction operator+ (const Fraction\u0026amp; f){ return Fraction(....); } private: int m_numerator; //fenzi int m_denominator;// fenmu }; Fraction f(3,5); Fraction d = f + 4; If we add explicit to ctor, then the 4 can\u0026rsquo;t convert to Fraction implicitly, which causes the ambigurity disappear. But the f+ 4 is a double type , and you assign a double type to a Fraction which cause conversion type error.\nexplicit.cc: In function ‘int main()’: explicit.cc:21:18: error: conversion from ‘double’ to non-scalar type ‘Fraction’ requested 21 | Fraction d = f + 4; // which will cause ambiguous | ~~^~~ STL conversion example template\u0026lt;class Alloc\u0026gt; class vector\u0026lt;bool, Alloc\u0026gt; { public: typedef __bit_reference reference; protected: reference operator[](size_type n) { return *(begin() + difference_type(n)); } }; struct __bit_reference { unsigned int *p; unsigned int mask; public: operator bool() const { return !(!(*p \u0026amp; mask)); } }; ","permalink":"http://localhost:1313/posts/c++_basic/1_explicit_typefunction/","summary":"\u003ch2 id=\"conversion-function\"\u003econversion function\u003c/h2\u003e\n\u003cp\u003eform: \u003cstrong\u003eoperator typename()\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFraction\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Fraction(\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e num, \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e den\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e m_numerator(num), m_denominator(den) {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edouble\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e) (m_numerator \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e m_denominator);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m_numerator; \u003cspan style=\"color:#75715e\"\u003e//fenzi\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e m_denominator;\u003cspan style=\"color:#75715e\"\u003e// fenmu\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eFraction \u003cspan style=\"color:#a6e22e\"\u003ef\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e d \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e f;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe conversion function is aimed to let compiler know. When the compiler tries to compile the line double d = 4 + f; it will see if operator + (double, Fraction) is defined, or whether f is able to convert to double.\nFinally, the compiler will try the latter one, convert f to double use the operator double() function in Fraction.\nActually you can write many conversion function as long as they are meaningful to the user.\u003c/p\u003e","title":"1-explicit-typefunction-object-model-cpp"},{"content":"inheritance with virtual function virtual function The inheritance with virtual function can make the most of it. The member function has three forms classified by virtual. And the virtual function needs to be overriden by derived class.\nnon-virtual function (with no virtual identifier) impure virtual function (with virtual identifier and default definition) pure virtual (with virtual identifier, = 0) // fixme Sometimes we need a default virtual function definition so impure is necessary.\nclass Shape { public: virtual void draw() const = 0; // pure virtual function virtual void error(const std::string \u0026amp; msg); // impure virtual function int objecId() const; // non-virtual function }; class Rectangle: public Shape{ }; class Ellipse: public Shape{ }; Template Method Template Method is a design pattern in oop and ood.Example, MFC, application framework. It means delay the action until the derived class to override it.\n//framework CDocument:: OnFileOpen() { ... Serialize(); ... }; // application class CMyDoc: public CDocument { //override virtual Serialize() {...} }; // main main() { CMyDoc myDoc; myDoc.OnFileopen(); } CDocument::OnFileOpen(\u0026amp;myDoc); -\u0026gt; this-\u0026gt;Serialize() in OnFileOpen inheritance plus composition The two forms of this type are listed below. Form one: I will write a piece of code to figure it out that base ctor calls first or component ctor calls first.\n#include \u0026lt;iostream\u0026gt; using namespace std; class Base{ public: Base() { cout \u0026lt;\u0026lt; \u0026#34;Base() ctor\u0026#34; \u0026lt;\u0026lt; endl; } ~Base() { cout \u0026lt;\u0026lt; \u0026#34;~Base() dtor\u0026#34; \u0026lt;\u0026lt; endl; } }; class Component { public: Component() { cout \u0026lt;\u0026lt; \u0026#34;Component() ctor\u0026#34; \u0026lt;\u0026lt; endl; } ~Component() { cout \u0026lt;\u0026lt; \u0026#34;~Component() dtor\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived: public Base{ public: Derived() { cout \u0026lt;\u0026lt; \u0026#34;Derived() ctor\u0026#34; \u0026lt;\u0026lt; endl; } ~Derived() { cout \u0026lt;\u0026lt; \u0026#34;~Derived() dtor\u0026#34; \u0026lt;\u0026lt; endl; } private: Component b; }; int main() { Derived b; return 0; } output: Base() ctor Component() ctor Derived() ctor ~Derived() dtor ~Component() dtor ~Base() dtor Form two: The latter ctor and dtor order is clear.\ninheritance plus delegation in ppt, or word, we have the same data value but different view of this data. This is called design pattern Obsever.\nclass Subject { int m_value; vector\u0026lt;Obsever*\u0026gt; m_views; public: void attach(Obsever *obs){ m_views.push_back(obs); } void set_val(int val){ m_value = val; notify; } void notify(){ for(int i = 0; i \u0026lt; m_views.size(); i++) m_views[i]-\u0026gt;update(this, m_value); } }; class Obsever { public: virtual void update(Subject *sub, int value) = 0; }; The outline of this is like, Some class inheriting from Observer can be inside the object vector, each one use update virtual function can do different things-polymorphism.\ndesign pattern inheritance plus delegation Example-Prototype\n#include \u0026lt;iostream\u0026gt; using namespace std; enum imageType{ LSAT,SPOT }; class Image { public: virtual void draw() = 0; static Image* findAndClone(imageType); protected: virtual imageType returnType() = 0; virtual Image* clone() = 0; //As each subclass of Image is declared, it registers its prototype static void addPrototype(Image *image){ _prototypes[_nextSlot++] = image; } private: // addPrototype() saves each registered prototype here static Image* _prototypes[10]; static int _nextSlot; }; //definition when you declare static inside class Image *Image::_prototypes[]; int Image::_nextSlot; //Client Calls this public static member function when it needs an instance of //an Image subclass Image* Image::findAndClone(imageType type){ for(int i = 0; i \u0026lt; _nextSlot; i++){ if(_prototypes[i]-\u0026gt;returnType() == type) return _prototypes[i]-\u0026gt;clone(); } return NULL; } class LandSatImage : public Image { public: imageType returnType(){ return LSAT; } void draw() { cout \u0026lt;\u0026lt; \u0026#34;LandSatImage::draw\u0026#34; \u0026lt;\u0026lt; _id \u0026lt;\u0026lt; endl; } // when clone() is called, call the one-argument ctor with a dummy argument Image *clone() { return new LandSatImage(1); } protected: //This is only called from clone LandSatImage(int dummy){ _id = _count ++; } private: // Mechanism for initializing an Image subclass // this causes the default ctor to be called, which registered the subclass\u0026#39;s prototype static LandSatImage _landSatImage; // This only called when the private static data member is initialized LandSatImage(){ addPrototype(this); } // Normal State per instance mechanism int _id; static int _count; }; // Register the subclass\u0026#39;s prototype LandSatImage LandSatImage::_landSatImage; // Initialize the \u0026#34;state\u0026#34; per instance mechanism int LandSatImage::_count = 1; class SpotImage:public Image { public: imageType returnType(){ return SPOT; } void draw() { cout \u0026lt;\u0026lt; \u0026#34;SpotImage::draw\u0026#34; \u0026lt;\u0026lt; _id \u0026lt;\u0026lt; endl; } Image *clone() { return new SpotImage(1); } protected: SpotImage(int dummy){ _id = _count++; } private: SpotImage() { addPrototype(this); } static SpotImage _spotImage; int _id; static int _count; }; SpotImage SpotImage::_spotImage; int SpotImage::_count = 1; // Simulated stream of creation requests const int NUM_IMAGES = 8; imageType input[NUM_IMAGES] = { LSAT, LSAT, LSAT, SPOT, LSAT, SPOT, SPOT, LSAT }; int main() { Image *images[NUM_IMAGES]; // Given an image type, find the right prototype, and return a clone for (int i = 0; i \u0026lt; NUM_IMAGES; i++) images[i] = Image::findAndClone(input[i]); // Demonstrate that correct image objects have been cloned for (int i = 0; i \u0026lt; NUM_IMAGES; i++) images[i]-\u0026gt;draw(); // Free the dynamic memory for (int i = 0; i \u0026lt; NUM_IMAGES; i++) delete images[i]; } Composite design pattern for DB(small file system) class Component { int value; //default private public: Component(int val) : value(val) {} virtual void add(Component *){} // should not pure-virtual for Primitive is not a dir }; class Primitive:public Component { public: Primitive(int val): Component(val){} }; class Composite : public Component { vector\u0026lt;Component*\u0026gt; v; public: Composite(int val) : Component(val) {} void add(Component *com) { v.push_back(com); } }; ","permalink":"http://localhost:1313/posts/c++_basic/8_virtual_polymorphism/","summary":"\u003ch2 id=\"inheritance-with-virtual-function\"\u003einheritance with virtual function\u003c/h2\u003e\n\u003ch3 id=\"virtual-function\"\u003evirtual function\u003c/h3\u003e\n\u003cp\u003eThe inheritance with virtual function can make the most of it.\nThe member function has three forms classified by \u003cstrong\u003evirtual\u003c/strong\u003e. And the virtual function needs to be \u003cstrong\u003eoverriden\u003c/strong\u003e by derived class.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003enon-virtual function (with no virtual identifier)\u003c/li\u003e\n\u003cli\u003eimpure virtual function (with virtual identifier and default definition)\u003c/li\u003e\n\u003cli\u003epure virtual (with virtual identifier, = 0)  // fixme\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSometimes we need a default virtual function definition so impure is necessary.\u003c/p\u003e","title":"8-virtual-polymorphism-basic-object-oriented-cpp"},{"content":"OOP and OOD object oriented programming, object oriented design We have three tools to design a good program, inheritance, composition, and delegation.\nInheritance is-a The public inheritance way is \u0026ldquo;is-a\u0026rdquo;, like person is a creature. dog is a animal. etc.\noutline The same outline as composition.\nctor and dtor The order of calling ctor when construct the class is from inner to outter, the dtor is the opposite.\nDerived::Derived(...) : Base() {}; Derived::~Derived(...) : {... ~Base();}; Besides, the compiler will automatically add the ctor and dtor, if ctor does ease your tastes then you need to change you like. Note: the base dtor must using virtual identifier, otherwise it will cause undefined behavior.\ncomposition has-a template \u0026lt;class T\u0026gt; class queue{ ... protected: deque\u0026lt;T\u0026gt; c; public: bool empty() const { return c.empty;} size_type size() const { return c.size(); } reference front() { return c.front(); } reference back() { return c.back(); } void push( const value_type\u0026amp;x) { c.push_back(x);} void pop() { c.pop_front();} }; The outline of the queue class is like, adapter design pattern Also, it is a design pattern named Adapter, which means I have a great and more sophisticated class , and i wanna implement a simpler class, then I use the more complicated one to do it.\nctor and dtor The order of calling ctor when construct the class is from inner to outter, the dtor is the opposite.\nContainer::Container(...) : Component() {}; Container::~Container(...) : {... ~Component();}; Besides, the compiler will automatically add the ctor and dtor, if ctor does ease your tastes then you need to change you like.\ndelegation composition by reference Handle / Body\n// file String.hpp class StringRep; class String { public: String(); String(const char* s); String(const String\u0026amp; str); ~String(); private: StringRep *rep; }; // file String.cpp #include \u0026#34;String.hpp\u0026#34; namespace { class StringRep { friend class String; StringRep(const char *s); ~StringRep(); int count;// reference counting char *rep; }; } String::String() {...} outline The outline of delegation is like. As you can see, a, b and c are sharing the same string \u0026ldquo;hello\u0026rdquo;, if each of them wants to change , it will cause COW technique. Another thing to notice is that, reference counting is necessary because of the sharing. That\u0026rsquo;s we can know how many object are instanced before call dtor.\n","permalink":"http://localhost:1313/posts/c++_basic/7_oop_ood/","summary":"\u003ch2 id=\"oop-and-ood\"\u003eOOP and OOD\u003c/h2\u003e\n\u003cp\u003eobject oriented programming, object oriented design\nWe have three tools to design a good program, inheritance, composition, and delegation.\u003c/p\u003e\n\u003ch3 id=\"inheritance\"\u003eInheritance\u003c/h3\u003e\n\u003ch4 id=\"is-a\"\u003e\u003cstrong\u003eis-a\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eThe public inheritance way is \u0026ldquo;is-a\u0026rdquo;, like person is a creature. dog is a animal. etc.\u003c/p\u003e\n\u003ch4 id=\"outline\"\u003eoutline\u003c/h4\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/c_plus_plus/images/7_inheritance.png\"\u003e\nThe same outline as composition.\u003c/p\u003e\n\u003ch4 id=\"ctor-and-dtor\"\u003ector and dtor\u003c/h4\u003e\n\u003cp\u003eThe order of calling ctor when construct the class is from inner to outter, the dtor is the opposite.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDerived\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eDerived(...) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e Base() {};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDerived\u003cspan style=\"color:#f92672\"\u003e::~\u003c/span\u003eDerived(...) \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e {... \u003cspan style=\"color:#f92672\"\u003e~\u003c/span\u003eBase();};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBesides, the compiler will automatically add the ctor and dtor, if ctor does ease your tastes then you need to change you like.\nNote: the base dtor must using \u003cstrong\u003evirtual\u003c/strong\u003e identifier, otherwise it will cause undefined behavior.\u003c/p\u003e","title":"7-oop-ood-object-oriented-cpp"},{"content":"static static member data only has one slice in memory, and need to be definition.\nstatic member function The only way to access static member data is using static member function.Besides, there is no this pointer in static member function.\ncomplex c1; complex c2(2,1); cout \u0026lt;\u0026lt; c1.real(); cout \u0026lt;\u0026lt; c2.imag(); ---\u0026gt;this pointer. cout \u0026lt;\u0026lt; Complex::real(\u0026amp;c1); cout \u0026lt;\u0026lt; Complex::imag(\u0026amp;c2); The member function only has one slice, it needs different address of object to access data. Example using static:\nclass A{ public: static A\u0026amp; getInstance() { return a; } setup() { ... } private: A(); A(const A\u0026amp; rhs); static A a; }; // good example class A{ public: static A\u0026amp; getInstance(); setup() { ... } private: A(); A(const A\u0026amp; rhs); ... }; static A\u0026amp; A::getInstance(){ static A a; return a; } ... A::getInstance().setup(); The first example is not good because no matter when you need a class named A, it is still be in memory. So instead of still in memory, we choose another one to create when you need one using static local object.\nExample static, two ways to access static function\nobject class name class Account { public: static double m_rate; //static double m_rate = 9; static void set_rate(const double\u0026amp; rate) { m_rate = rate;} }; double Account::m_rate = 8; int main(){ Account::set_rate(8); Account a; a.set_rate(5); } Note, definition out of class is necessary because in class this is shown of declaration. but it\u0026rsquo;s not allowed to define in class which will expose error.\ncout class _IO_ostream_withassign : public ostream{ }; extern _IO_ostream_withassign cout; class ostream: virtual public ios { public: ostream\u0026amp; operator\u0026lt;\u0026lt; (int n); ostream\u0026amp; operator\u0026lt;\u0026lt; (unsigned int n); ostream\u0026amp; operator\u0026lt;\u0026lt; (char c); ... }; cout is kind of ostream, and there are many operator\u0026lt;\u0026lt; overload function.\ntemplate The template will be compiled successfully, but when called by user, it will be compiled again which might cause error. And the most important thing is operator overload function. The aim of template is generalization.\ntemplate class template\u0026lt;typename T\u0026gt; class complex { private: T re, ra; } .... complex\u0026lt;int\u0026gt; c1; complex\u0026lt;double\u0026gt; c1; When the compiler sees the Complex\u0026lt;int\u0026gt; or Complex\u0026lt;double\u0026gt; it will generate two slices of Complex has different type. This is kind of wasteful of memory but it\u0026rsquo;s necessary.\ntemplate function stone r1(2,3), r2(2,0), r3; r3 = min(r1, r2); --\u0026gt; template \u0026lt;class T\u0026gt; inline const T\u0026amp; min(const T\u0026amp; a, const T\u0026amp; b) { return a \u0026lt; b ? a : b; } --\u0026gt; class stone { public: ... bool operator \u0026lt; (const stone\u0026amp; t2) { return _weight \u0026lt; t2._weight; } private: double _weight; double _height; }; The compiler will do argument deduction to function template, which we don\u0026rsquo;t have to add \u0026lt;int\u0026gt; or \u0026lt;stone\u0026gt; after the min function. After that, the min function will call the operator \u0026lt; function. So the class designer must overload this function.\nAnd the more details about template is in 3_template.org in object_mode directory\nnamespace namespace std{ } using namespace std; using std::cout; Two ways to use it.\nusing directive (valid all) using delcaration(valid some case) Example\nnamespace jj01 { void test_member_template(); }; namespace jj02 { void test_member_template(); }; int main() { jj01::test_member_template(); jj02::test_member_template(); }; When using namespace with different departments, the conflict disappears which is really cooperative.\n","permalink":"http://localhost:1313/posts/c++_basic/6_complement/","summary":"\u003ch2 id=\"static\"\u003estatic\u003c/h2\u003e\n\u003ch3 id=\"static-member-data\"\u003estatic member data\u003c/h3\u003e\n\u003cp\u003eonly has one slice in memory, and need to be definition.\u003c/p\u003e\n\u003ch3 id=\"static-member-function\"\u003estatic member function\u003c/h3\u003e\n\u003cp\u003eThe only way to access static member data is using static member function.Besides, there is no \u003cstrong\u003ethis\u003c/strong\u003e pointer in static member function.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex c1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex \u003cspan style=\"color:#a6e22e\"\u003ec2\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e c1.real();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e c2.imag();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e---\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e pointer.\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e Complex\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ereal(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ec1);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e Complex\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eimag(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003ec2);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe member function only has one slice, it needs different address of object to access data.\n\u003cimg loading=\"lazy\" src=\"/c_plus_plus/images/6_static_object.png\"\u003e\u003c/p\u003e\n\u003cp\u003eExample using static:\u003c/p\u003e","title":"6-complement-objcet-oriented-cpp"},{"content":"stack and heap stack memory is used for local object, local var, argument passed, return val. heap memory is dynamically allocated using new, this memory is managed by OS.\nlife span heap object { complex *p = new complex(2,1); } when the program goes out of the scope, the object pointed by p is still alive but we can\u0026rsquo;t access because the p is local var. In this case, it will cause memory leak , so we need to release when not use it anymore.\nglobal object the whole program\nstatic local object the whole program\nnew new expression memory firstly and then evoke the ctor, it will be divided three ops like that.\nallocate memory ( using c-malloc ) convert type ctor complex *pc = new complex(2,1); ---\u0026gt; void *mem = operator new (sizeof(complex)); // operator new function is c++ function which will use malloc. pc = static_cast\u0026lt;complex*\u0026gt;(mem); pc-\u0026gt;complex::complex(2,1); // Complex::Complex(pc, 2, 1);// this delete call dtor first and then release memory.\ndtor free memory using free function complex *pc = new complex(2,1); ... delete pc; complex::~complex(pc);// dtor operator delete(pc); // operator delete is c++ inside function which will call free to release memory. complex *ps = new String(\u0026#34;hello\u0026#34;); ... delete ps; 2. ps--\u0026gt;|-----| 1. | |----------\u0026gt;|-------------| |-----| |hello | |-------------| step1. will call String::~String() dtor, delete m_data, release allocate memory storing hello string (actually release the pointer storage). step2. will call delete operator which free(ps) the memory storing pointer to String.\ndetail of allocated memory in c++ one element array |-------| |-------| |malloc | |malloc | |cookie | |cookie | |-------| |-------| | | | size | | | |-------| |Complex| |Complex| | | |-------| | | |Complex| |-------| |-------| | pad | | pad | |-------| |-------| |malloc | |malloc | |cookie | |cookie | |-------| |-------| When you don\u0026rsquo;t use new [] ( new array) and delete [] (delete array) in pair, it will cause memory leak which doesn in your diet.\nString *p = new String [3]; | String *p = new String [3]; delete[] p; | delete p; wake up 3 dtor,another one just wake up one time. |------| | |----\u0026gt;|------| | | | | | | | | | | |------| |------| | |----\u0026gt;|------| | | | | | | | | | | |------| |------| | | | |----\u0026gt;|------| | | | | |------| | | |------| And the string \u0026ldquo;world\u0026rdquo; and string \u0026ldquo;zhh\u0026rdquo; is still in memory without release in one time dtor.\n","permalink":"http://localhost:1313/posts/c++_basic/5_new_delete/","summary":"\u003ch2 id=\"stack-and-heap\"\u003estack and heap\u003c/h2\u003e\n\u003cp\u003estack memory is used for local object, local var, argument passed, return val.\nheap memory is dynamically allocated using new, this memory is managed by OS.\u003c/p\u003e\n\u003ch3 id=\"life-span\"\u003elife span\u003c/h3\u003e\n\u003ch4 id=\"heap-object\"\u003eheap object\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  complex \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003ep \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e complex(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewhen the program goes out of the scope, the object pointed by p is still alive but we can\u0026rsquo;t access because the p is local var. In this case, it will cause memory leak , so we need to release when not use it anymore.\u003c/p\u003e","title":"5-new-delete-basic-object-oriented-cpp"},{"content":"Big three why we need big there, and what conditions do we need big three? The class contains pointer must include these three functions. Note: if we don\u0026rsquo;t write copy ctor ,copy op= and dtor, the compiler will generate automatically. For copy ctor it will copy bit by bit directly. For dtor it will do nothing.\ncopy ctor copy op= (copy assignment function) dtor (destructor function) String Class with pointer.\nString Class class String { }; String::function ... Global-function int main(){ String s1(); String s2(\u0026#34;hello\u0026#34;); String s3(s1); // copy ctor cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; s3 = s2; // copy op= cout \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; } String Class Outline class String { public: String (const char* cstr = 0); String (const String\u0026amp; str); String\u0026amp; operator=(const String\u0026amp; str); ~String(); char *get_c_str() const { return m_data; } private: char *m_data; } ctor The string has two formats like, one is lens + string, another one is string end with \u0026rsquo;\\0\u0026rsquo;. C and C++ choose the latter one.\ninline String::String(const char* cstr = 0) { if(cstr){ m_data = new char[ strlen(cstr) + 1 ]; strcpy(m_data, cstr); }else{ m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } } inline String::~String() { delete [] m_data; } copy op= If we don\u0026rsquo;t provide a deep copy function of copy assignment, the compiler will generate a shadow copy version, which will causes memory leak in the future.\nI will show you a img to illustrate this danger and the difference of shadow copy and deep copy. And the alias in c++ is dangerous.\ninline String\u0026amp; String::operator =(const String\u0026amp; str) { // check self assignment if(this == \u0026amp;str) return *this; delete[] m_data; m_data = new char [strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); return *this; } // String s1(\u0026#34;hello\u0026#34;); String s2(s1); s2 = s1; Don\u0026rsquo;t forget self assignment check, it will cause undefined error when you don\u0026rsquo;t.\nAfter deletion, the strcpy will access the memory which just deleted, will cause UB( undefined behavior).\ncopy ctor Note: brothers between each are friends, so it can access private data like str.m_data.\ninline String::String (const String \u0026amp; str) { m_data = new char[ strlen(str.m_data) + 1 ]; strcpy(m_data, str.m_data); } { String s1(\u0026#34;hello\u0026#34;); String s2(s1); //String s2 = s1; has the same meaning of String s2(s1); } output #include \u0026lt;iostream\u0026gt; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const String\u0026amp; s) { return os \u0026lt;\u0026lt; s.get_c_str(); } String s1(\u0026#34;hello\u0026#34;); cout \u0026lt;\u0026lt; s1; ","permalink":"http://localhost:1313/posts/c++_basic/4_big_three/","summary":"\u003ch2 id=\"big-three\"\u003eBig three\u003c/h2\u003e\n\u003cp\u003ewhy we need big there, and what conditions do we need big three?\nThe class contains pointer must include these three functions.\nNote: if we don\u0026rsquo;t write copy ctor ,copy op= and dtor, the compiler will generate automatically.\nFor copy ctor it will copy bit by bit directly.\nFor dtor it will do nothing.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecopy ctor\u003c/li\u003e\n\u003cli\u003ecopy op= (copy assignment function)\u003c/li\u003e\n\u003cli\u003edtor (destructor function)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eString Class with pointer.\u003c/p\u003e","title":"4-big-three-object-oriented-cpp"},{"content":"operator overload member function the member function overload contains this pointer implicitly, but you don\u0026rsquo;t have to pass the argument. you can use it freely.\ninline complex\u0026amp; __doapl(complex* ths, const complex\u0026amp; r) { ths-\u0026gt;re += r.re; ths-\u0026gt;im += r.im; return *ths; } inline complex\u0026amp; complex::operator += (const complex\u0026amp; r) { return __doapl(this, r); } //... complex c1(2,1); complex c2(5); c2 += c1; c3 += c2 += c1; why we need return by reference when we define += overload function? If you just use c2 += c1; you can define void return type, but when there is a consecutive assignment which means the expression must return a type that can be passed to another +=. So complex \u0026amp; matters. c3 += c2 += c1\nnon-member function (global function) There is no this pointer, it belongs to global function.\ninline complex operator + (const complex \u0026amp;x, const complex \u0026amp;y) { return complex (real(x) + real(y), imag(x) + imag(y)); } inline complex operator + (const complex \u0026amp;x, double y) { return complex (real(x) + y, imag(x)); } inline complex operator + (double x, const complex \u0026amp;y) { return complex (x + real(y) , imag(y)); } //... complex c1(2,1); complex c2; c2 = c1 + c2; c2 = c1 + 5; c2 = 7 + c1; Besides, it used temp object\u0026mdash; typename().There is no allocated storage provided, you have to return by value by creating a local object.\nOther definitions outside the class.\ninline complex //inline complex\u0026amp; ok operator + (const complex \u0026amp;x) { return x; } inline complex operator - (const complex \u0026amp;x) { return complex(-real(x), -imag(x)); } There is another question remaining that in +(positive function), there isn\u0026rsquo;t newer things created, you can return by reference.\nAnother example:\ninline complex conj (const complex \u0026amp; x) { return complex( real(x), -imag(x)); } #include \u0026lt;iostream\u0026gt; ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;os, const complex\u0026amp; x) { return os \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; real(x) \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; imag(x) \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; } complex c1(2,1) cout \u0026lt;\u0026lt; conj(c1) cout \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; conj(c1); The operator\u0026lt;\u0026lt; overload function must be non-member function, because the complex is new than ostream and the first parameter is always an ostream object. It would have to be a member of the ostream class but we can not change). And \u0026lt;\u0026lt; left operand is cout, right operand is complex x; return by reference is for sure in case of consecutive usage.\n","permalink":"http://localhost:1313/posts/c++_basic/3_operator_overload_typeobject/","summary":"\u003ch2 id=\"operator-overload\"\u003eoperator overload\u003c/h2\u003e\n\u003ch3 id=\"member-function\"\u003emember function\u003c/h3\u003e\n\u003cp\u003ethe member function overload contains this pointer implicitly, but you don\u0026rsquo;t have to pass the argument. you can use it freely.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003einline\u003c/span\u003e complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e__doapl(complex\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ths, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e r)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ths\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003ere \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e r.re;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ths\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eim \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e r.im;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eths;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003einline\u003c/span\u003e complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e r)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__doapl\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003ethis\u003c/span\u003e, r);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e//...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ecomplex \u003cspan style=\"color:#a6e22e\"\u003ec1\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex \u003cspan style=\"color:#a6e22e\"\u003ec2\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ec2 \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e c1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ec3 \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e c2 \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e c1;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ewhy we need return by reference when we define \u003cstrong\u003e+=\u003c/strong\u003e overload function? If you just use c2 += c1; you can define void return type, but when there is a consecutive assignment which means the expression must return a type that can be passed to another +=. So \u003cstrong\u003ecomplex \u0026amp;\u003c/strong\u003e matters. \u003cstrong\u003ec3 += c2 += c1\u003c/strong\u003e\u003c/p\u003e","title":"3-operator-overload-object-oriented-cpp"},{"content":"argument pass pass by value pass by reference (to const) Advice: all arguments passed by reference, if it\u0026rsquo;s not changed inside the function add const identifier. Besides, in reality, the reference is a pointer.\nclass complex { public: complex (double r= 0, double i= 0) : re(r), im(i) {} complex\u0026amp; operator+=(const complex\u0026amp;); double real() const{return re;} double imag() const{return im;} private: double re, im; friend complex\u0026amp; __doapl (complex*, const complex\u0026amp;); } ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; os, const complex\u0026amp; x) { return os \u0026lt;\u0026lt; \u0026#39;(\u0026#39; \u0026lt;\u0026lt; real(x) \u0026lt;\u0026lt; \u0026#39;,\u0026#39; \u0026lt;\u0026lt; imag(x) \u0026lt;\u0026lt; \u0026#39;)\u0026#39;; } //... complex c1(2,1); complex c2; cout \u0026lt;\u0026lt; c1; cout \u0026lt;\u0026lt; c2 \u0026lt;\u0026lt; c1; return value return value return reference Advice: all return value are set reference, if some cases happen that it\u0026rsquo;s not allowed to return reference then return value.\nfriend class complex; complex\u0026amp; __doapl (complex* ths, const complex\u0026amp; r); class complex { public: complex (double r= 0, double i= 0) : re(r), im(i) {} complex\u0026amp; operator+=(const complex\u0026amp;); double real() const{return re;} double imag() const{return im;} private: double re, im; friend complex\u0026amp; __doapl (complex*, const complex\u0026amp;); } inline complex\u0026amp; __doapl (complex* ths, const complex\u0026amp; r) { ths-\u0026gt;re += r.re; ths-\u0026gt;im += r.im; return *ths; } friend function can access the private data.( direct access) So we don\u0026rsquo;t have to add class scope operator before the definition of the friend function. Note: it\u0026rsquo;s allowed to declare an inline function in public or private. Another example, objects belong to the same classs are friend each other.\nclass complex { public: complex (double r = 0, double i = 0) : re(r), im(i) {} int func(const comple\u0026amp; param) { return param.re + param.im; } private: double re, im; }; //..... { complex c1(2,1); complex c2; c2.func(c1); } Good Class data are all put into private access level 2.pass arg by reference (to const) 3.return by reference 4.const member function 5.ctor list initialization (:)\nFunction Definition when to pass by reference, when to return by reference Let\u0026rsquo;s see the argument pass procedure. There are two cases,\nthe first arg will be changed, and the second won\u0026rsquo;t change, actually we have space to store the changed value, then we return by reference like +=. we don\u0026rsquo;t have allocated space to store the changed value, then we have to allocate memory on stack, and return by value. like +. example:\ninline complex\u0026amp; __doapl( complex *ths, const complex\u0026amp; r) { ths-\u0026gt;re += r.re; ths-\u0026gt;im += r.im; return *ths; // we actually have space to store. } inline complex\u0026amp; complex::operator += (const complex\u0026amp; r) { return __doapl(this, r); } ","permalink":"http://localhost:1313/posts/c++_basic/2_pass_and_return/","summary":"\u003ch2 id=\"argument-pass\"\u003eargument pass\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003epass by value\u003c/li\u003e\n\u003cli\u003epass by reference (to const)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdvice: all arguments passed by reference, if it\u0026rsquo;s not changed inside the function add \u003cstrong\u003econst\u003c/strong\u003e identifier.\nBesides, in reality, the reference is a pointer.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecomplex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  complex (\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e r\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e i\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e re(r), im(i)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereal\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e{\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e re;}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eimag\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e{\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e im;}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eprivate\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e re, im;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003efriend\u003c/span\u003e complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e __doapl (complex\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eostream\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eoperator\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e (ostream\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e os, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e complex\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e x)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e os \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;(\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e real(x) \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;,\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e imag(x) \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;)\u0026#39;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e//...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003ecomplex \u003cspan style=\"color:#a6e22e\"\u003ec1\u003c/span\u003e(\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex c2;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e c1;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e c2 \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e c1;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"return-value\"\u003ereturn value\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ereturn value\u003c/li\u003e\n\u003cli\u003ereturn reference\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdvice: all return value are set reference, if some cases happen that it\u0026rsquo;s not allowed to return reference then return value.\u003c/p\u003e","title":"2-pass-return-object-oriented-cpp"},{"content":"C-plus-plus profile object object based -class without pointer members -Complex -class with pointer members -String object oriented -inheritance -composition -delegation data and functions C type[data] [functions]\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt;variable in memory C++ class/struct [data, functions]\u0026mdash;\u0026mdash;\u0026gt;object in memory Note: the function of class only has one copy which means when you create class only data occupies memory and vptr (if has virtual function inside class).\nC-plus-plus coding program .h/.cpp/.hpp never mind\ngurad declaration #progam once // #ifndef __COMPLEX__ #define __COMPLEX__ #endif Header Layout class-delcaration class complex { } class-definition complex::function ... ... forward-declarations class complex; template complex not only double real and image, maybe float or int\ntemplate\u0026lt;typename T\u0026gt; class complex { private: T re, ra; } complex\u0026lt;int\u0026gt; c1; complex\u0026lt;double\u0026gt; c1; inline when you define a function in class body\nclass complex { public: complex (double r= 0, double i= 0) : re(r), im(i) {} complex\u0026amp; operator+=(const complex\u0026amp;); double real() const{return re;} double imag() const{return im;} private: double re, ra; friend complex\u0026amp; __doapl (complex*, const complex\u0026amp;); } The real/imag function will be canditate for inline functions automatically.Btw, the way it becomes inline function depends on the complier and the complexity of the function itself.\nConstructor function (ctor) access level public protected ( in which I don\u0026rsquo;t give it to public interface and differs from private function , I can use it) protected example in 8_virtual_polymorphism.org file. private are not allowed by outside of the class\nclass complex { public: complex (double r= 0, double i= 0) : re(r), im(i) {} complex\u0026amp; operator+=(const complex\u0026amp;); double real() const{return re;} double imag() const{return im;} private: double re, im; friend complex\u0026amp; __doapl (complex*, const complex\u0026amp;); } .... complex c1(2,1); cout \u0026lt;\u0026lt; c1.re; //not allowed cout \u0026lt;\u0026lt; c1.im; //not allowed complex c1(2,1); cout \u0026lt;\u0026lt; c1.real(); cout \u0026lt;\u0026lt; c1.imag(); constructor (ctor) function name is class no return type default argument initialization list ( assignment not advised) public: complex (double r= 0, double i= 0) : re(r), im(i) {} initialization stage:\ninitialization :re(r), im(i) assignment when you use assignment to initialize private variable, it is allowed but low-efficiency\npublic: complex (double r= 0, double i= 0) { re = r; im = i;} ctor function overloading That means ctor has multiple forms, actually the overloading function has different name viewed by compiler.\nvoid real(double r ) {re = r;} viewed by compiler, ?real@Complex@@QBENXZ ?real@Complex@@QAENABN@Z however, when you define two ctor functions.\nclass complex { public: complex (double r= 0, double i= 0) : re(r), im(i) {} complex () : re(0), im(0) {} ... complex c1; complex c2(); These two functions are not allowed, that is because the compiler doesn\u0026rsquo;t deccide which one to call when construct c1 and c2, i mean both the ctor functions are ok to called. It is defined ok but called error, and it will print messages like that below.\ncomplex_test.cpp:14:11: error: call of overloaded ‘complex()’ is ambiguous 14 | complex c1; | ^~ In file included from complex_test.cpp:2: complex.h:17:3: note: candidate: ‘complex::complex()’ 17 | complex (): re (0), im (0) { } | ^~~~~~~ complex.h:16:3: note: candidate: ‘complex::complex(double, double)’ 16 | complex (double r = 0, double i = 0): re (r), im (i) { } brace initialization In the last example above, if you use complex c2(); to declare an object, the compiler will think it might be a function declaration or object declaration which confuses the compiler. So, if you wanna use default ctor you can remove the (), or change it to {} braces. complex c2{}; complex c2;\ncomplex_test.cpp:14:13: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse] 14 | complex c2(); | ^~ complex_test.cpp:14:13: note: remove parentheses to default-initialize a variable 14 | complex c2(); | ^~ | -- complex_test.cpp:14:13: note: or replace parentheses with braces to value-initialize a variable private ctor Singleton - design pattern, means just only one instance of a class.\nclass A{ public: static A\u0026amp; getInstance(); setup() { ... } private: A(); A(const A\u0026amp; rhs); ... }; static A\u0026amp; A::getInstance(){ static A a; return a; } ... A::getInstance().setup(); const member function Advice: member function\nmight change the private value might not change the private value The function which not change the private value need to add const identifier. The position of const need to add after the ) before the { symbol\ndouble real() const{return re;} double imag() const{return im;} double real() {return re;} double imag() {return im;} // example { const complex c1(2,1) cout \u0026lt;\u0026lt; c1.real(); // error conflict! cout \u0026lt;\u0026lt; c1.imag(); } ","permalink":"http://localhost:1313/posts/c++_basic/1_ctor/","summary":"\u003ch2 id=\"c-plus-plus-profile\"\u003eC-plus-plus profile\u003c/h2\u003e\n\u003ch3 id=\"object\"\u003eobject\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eobject based\n-class without pointer members\n-Complex\n-class with pointer members\n-String\u003c/li\u003e\n\u003cli\u003eobject oriented\n-inheritance\n-composition\n-delegation\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"data-and-functions\"\u003edata and functions\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eC type[data] [functions]\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt;variable in memory\u003c/li\u003e\n\u003cli\u003eC++ class/struct [data, functions]\u0026mdash;\u0026mdash;\u0026gt;object in memory\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote: the function of class only has one copy which means when you create class only data occupies memory and vptr (if has virtual function inside class).\u003c/p\u003e\n\u003ch3 id=\"c-plus-plus-coding-program\"\u003eC-plus-plus coding program\u003c/h3\u003e\n\u003cp\u003e.h/.cpp/.hpp never mind\u003c/p\u003e\n\u003ch3 id=\"gurad-declaration\"\u003egurad declaration\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#progam once\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e//\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#ifndef __COMPLEX__\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define __COMPLEX__\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#endif\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"header-layout\"\u003eHeader Layout\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eclass-delcaration\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecomplex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col\u003e\n\u003cli\u003eclass-definition\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003efunction ... ...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col\u003e\n\u003cli\u003eforward-declarations\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecomplex\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"template\"\u003etemplate\u003c/h3\u003e\n\u003cp\u003ecomplex not only double real and image, maybe float or int\u003c/p\u003e","title":"1-basic-ctor-object-oriented-cpp"},{"content":"Object In this lab5, I am gonna to implent an IP interface for TCP/IP stack and IP router later in lab6. The IP interface is used to send etherframe using payload from IP layer. So, in this layer, we handle the mac etherframe in details. If we don\u0026rsquo;t konw the mac address of the next-hop IP address, we need to send ARP request to this subnet, then queuing the datagram until the ARP message received. After receiving the ARP message, we need to doc the \u0026lt;next-hop, mac\u0026gt; pair mapping for 30 secs in this lab, with this mapping, the next time sending to the same ip would not send ARP message again.\nThe most important thing we need to know that, the ARP protocol is based on the etherframe (aka MAC layer), which in another words to say, the ARP message is the payload of the etherframe except that it has special meaning of each field of the bytes.\nOk, Let\u0026rsquo;s see the ARP (address resolution protocol) in wiki. it says that ARP enables a host to send an IPv4 packet to another node in the local network by providing a protocol to get the MAC address associated with an IP address. The host broadcasts a request containing the node\u0026rsquo;s IP address, and the node with that IP address replies with its MAC addres Note: its message are directly encapsulated by a link layer protocol like MAC, and it is communicated within the boundaries of a single subnet and is never routed.\nARP packet structure I use an image from wiki to illustrate the structure of ARP message. Hardware Type ( HTYPE ):16 bits it specifys that which network link protocol type, use 1 indicates ethernet(MAC). Protocol Type ( PTYPE ): 16 bits This field specifys the internet protocol for which the ARP request is intended. Like IPV4 the value of this field is 0x0800. Hardware Length( HLEN ): 8 bits Length for Hardware type address, for ethernet is 6. Protocol Length (PLEN): 8 bits Length for Protocol address, for ipv4 is 4. Operation (OPER): 16 bits specifys the option of the sending, 1 for request 2 for reply. Sender Hardware Address (SHA): 48bits Media address of the sender. In an ARP request this field is used to indicate the address of the host sending the request. In an ARP reply this field is used to indicate the address of the host that the request was looking for. Sender Protocol Address (SPA): 32bits Internetwork address of the sender. Target Hardware Addres (THA): 48bits Media address of the intended receiver. In an ARP request this field is ignored. In an ARP reply this field is used to indicate the address of the host that originated the ARP request. Target Protocol Address(TPA): 32 bits Internetwork address of the intended reciever. Broadcast ARP message If we don\u0026rsquo;t the next-hop ethernet address, we need to send an ARP message to broadcast within the subnet. Here is the ARP message, assuming that the next-hop ip address is 192.168.0.1, our ethernet address is 48:32:12:98:78:90, our ip address is 4.3.2.1 I use an image to show the ARP message below. And the ARP message is within in etherframe, so the ARP message occupies the payload of the etherframe. The src is 48:32:12:98:78:90, and dst is ff:ff:ff:ff:ff:ff, which indicates a broadcast message.After that, we can just send the message to the subnet\nnetwork_interface structure of class we use linked-list as our main structure to handle the mapping and no-nexthop ip dgram.\nstruct ip_mac_map { // cache mapping IP-\u0026gt;MAC uint32_t ip; EthernetAddress mac; size_t ms_tick; }; struct dgram_no_mac { InternetDatagram dgm; uint32_t next_hop; size_t ms_tick; }; In this lab, each item of the list has a ms_tick to handle whether or not this mapping is valid and whether or not drop the dgram without nexthop ethernet address. The function tick method is just to update the mapping in the list file, if some of each exceeds 30 secs we drop it out, but be careful of erase list when iterating. Also it has the ability to decide whether or not drop the dgram in the no-mac dgram. Actually we don\u0026rsquo;t want to flood the network using ARP message repeatedly, so we need to check if the message we will send has the same ip as item in the no-mac linked list, and the item exists for less than 5 secs, we don\u0026rsquo;t send our arp message again, just queue or drop. (I didn\u0026rsquo;t handle that)\nwhy not queue? If i push staff for without no-mac of the nexthop, the next time arp message received, it might not be the first item pushed, and the queue can\u0026rsquo;t take out the second but only the head. That\u0026rsquo;s why I choose list to implent this.\nActually this lab is not hard, and there are also some cases to handle in the future. ","permalink":"http://localhost:1313/posts/cs144/lab5/","summary":"\u003ch2 id=\"object\"\u003eObject\u003c/h2\u003e\n\u003cp\u003eIn this lab5, I am gonna to implent an IP interface for TCP/IP stack and IP router later in lab6. The IP interface is used to send etherframe using payload from IP layer. So, in this layer, we handle the mac etherframe in details. If we don\u0026rsquo;t konw the mac address of the next-hop IP address, we need to  send ARP request to this subnet, then queuing the datagram until the ARP message received. After receiving the ARP message, we need to doc the \u0026lt;next-hop, mac\u0026gt; pair mapping for 30 secs in this lab, with this mapping, the next time sending to the same ip would not send ARP message again.\u003c/p\u003e","title":"cs144-lab5"},{"content":"Glue of CS144TCPSocket I will illustrate the glue for using CS144TCPSocket in one image. From the picture, we know that it\u0026rsquo;s our job to implement TCP/IP in user layer in this class. But how do our packets of network send to other computers through the internet ? The answer is to use tun/tap device under the linux kernel. The tun/tap device is kinda like a software net-card which tun device gives you raw IP packet and tap device gives you raw MAC dataframe. And follow the instructions of the tun.sh, setting the iptables to route makes our packet to go elsewhere.\nLet\u0026rsquo;s see what the tun.sh done in this lab.\ntun.sh The most important part of tun.sh is to create a tun/tap device and set the iproute tables. The snippet of the code is shown below.\nTUN_IP_PREFIX=169.254 local TUNNUM=\u0026#34;$1\u0026#34; TUNDEV=\u0026#34;tun$1\u0026#34; ip tuntap add mode tun user \u0026#34;${SUDO_USER}\u0026#34; name \u0026#34;${TUNDEV}\u0026#34; ip addr add \u0026#34;${TUN_IP_PREFIX}.${TUNNUM}.1/24\u0026#34; dev \u0026#34;${TUNDEV}\u0026#34; ip link set dev \u0026#34;${TUNDEV}\u0026#34; up ip route change \u0026#34;${TUN_IP_PREFIX}.${TUNNUM}.0/24\u0026#34; dev \u0026#34;${TUNDEV}\u0026#34; rto_min 10ms # Apply NAT (masquerading) only to traffic from CS144\u0026#39;s network devices iptables -t nat -A PREROUTING -s ${TUN_IP_PREFIX}.${TUNNUM}.0/24 -j CONNMARK --set-mark ${TUNNUM} iptables -t nat -A POSTROUTING -j MASQUERADE -m connmark --mark ${TUNNUM} echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward ubuntu:~$./tun.sh start 144 And I substitue this command to make it clear to see. Here is the translated snippet.\nip tuntap add mode tun user zyy name tun144 ip addr add 169.254.144.1/24 dev tun144 ip link set dev tun144 up ip route change 169.254.144.0/24 dev tun144 rto_min 10ms # Apply NAT (masquerading) only to traffic from CS144\u0026#39;s network devices iptables -t nat -A PREROUTING -s 169.254.144.0/24 -j CONNMARK --set-mark 144 iptables -t nat -A POSTROUTING -j MASQUERADE -m connmark --mark 144 echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward From the manual, we can bind an IP address to tun device. After binding, the network address is 169.254.144.0/24 which has 24bits subnet-mask. also, the broadcast address is 169.254.144.255/24 ,169.254.144.1/24 host address Note:default getway, set all host bit to 1 except the last bit. 169.254.144.254/24 default getway\nroute table show $ip route show default via 10.198.255.254 dev wlp1s0 proto dhcp metric 600 10.198.0.0/16 dev wlp1s0 proto kernel scope link src 10.198.129.197 metric 600 169.254.0.0/16 dev virbr0 scope link metric 1000 linkdown 169.254.144.0/24 dev tun144 scope link linkdown rto_min lock 10ms 169.254.144.0/24 dev tun144 proto kernel scope link src 169.254.144.1 linkdown 169.254.145.0/24 dev tun145 scope link linkdown rto_min lock 10ms 192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 linkdown $route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 10.198.255.254 0.0.0.0 UG 600 0 0 wlp1s0 10.198.0.0 0.0.0.0 255.255.0.0 U 600 0 0 wlp1s0 169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 virbr0 169.254.144.0 0.0.0.0 255.255.255.0 U 0 0 0 tun144 169.254.144.0 0.0.0.0 255.255.255.0 U 0 0 0 tun144 169.254.145.0 0.0.0.0 255.255.255.0 U 0 0 0 tun145 192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0 From the iproute tables, we know 169.254.144.0/24 network address can be routed to elsewhere catching the default getway.\nNAT (Network Address Translation) zyy@ubuntu:~$ sudo iptables -t nat -L Chain PREROUTING (policy ACCEPT) target prot opt source destination CONNMARK all -- 169.254.144.0/24 anywhere CONNMARK set 0x90 Chain INPUT (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination Chain POSTROUTING (policy ACCEPT) target prot opt source destination LIBVIRT_PRT all -- anywhere anywhere MASQUERADE all -- anywhere anywhere connmark match 0x90 Chain LIBVIRT_PRT (1 references) target prot opt source destination RETURN all -- 192.168.122.0/24 base-address.mcast.net/24 RETURN all -- 192.168.122.0/24 255.255.255.255 MASQUERADE tcp -- 192.168.122.0/24 !192.168.122.0/24 masq ports: 1024-65535 MASQUERADE udp -- 192.168.122.0/24 !192.168.122.0/24 masq ports: 1024-65535 MASQUERADE all -- 192.168.122.0/24 !192.168.122.0/24 In the CS144Lab4, webget app binds an ip-address of 169.254.144.9, which belongs to tun144 ip network.\nmultiplexer_config.source = { \u0026#34;169.254.144.9\u0026#34;, std::to_string( uint16_t( std::random_device()() ) ) }; As we can see the iptables above, let\u0026rsquo;s illustrate the meaning of it by picture. If the source is in 169.254.144.0/24 network address, it will be set as mark 0x90 using masquerade target to route to elsewhere. And when the packet is coming, the kernel will choose to route to write application. That\u0026rsquo;s the lab4 routing strategy.\nAnalyse Data I collected for about 5 hours of data from 20250312 9:00:00 to 20250312 14:19:00. And I write a python script file to analyse the data to answer the 10 questions.\nquestion 1: echo_reply_rate loss : 115 dup : 41 echo_receive_rate : 0.9987992440458167\nquestion 2: longest concecutive max_consecutive : 8309\nquestion 3: longest missing concecutive max_missing : 8\nquestion 4: independent or correlated N+1_reply_N_missing: 0.0006690501578540217 N+1_reply_N_reply : 0.999330949842146\nFrom the result, we can see that it\u0026rsquo;s not idependent.\nquestion 5/6: get minimum and maximum RTT min RTT : 20.2 max RTT : 495\nquestion 7: Make a graph of the RTT as a function of time. Label the x-axis with the actual time of day (covering the 2+-hour period), and the y-axis should be the number of milliseconds of RTT. question8: Make a histogram or Cumulative Distribution Function of the distribution of RTTs observed. What rough shape is the distribution? question9: make a graph of the correlation between “RTT of ping #N” and “RTT of ping #N+1”. The x-axis should be the number of milliseconds from the first RTT, and the y-axis should be the number of milliseconds from the second RTT. How correlated is the RTT over time? I see but not clear that if this time RTT is large, maybe the second is small.\ncs144 note :: scope operator which I haven\u0026rsquo;t noticed before ::close function when in function close\nvoid FileDescriptor::FDWrapper::close() { CheckSystemCall( \u0026#34;close\u0026#34;, ::close( fd_ ) ); eof_ = closed_ = true; } ","permalink":"http://localhost:1313/posts/cs144/lab4/","summary":"\u003ch2 id=\"glue-of-cs144tcpsocket\"\u003eGlue of CS144TCPSocket\u003c/h2\u003e\n\u003cp\u003eI will illustrate the glue for using CS144TCPSocket in one image.\n\u003cimg loading=\"lazy\" src=\"/cs144/images/lab4_cs144_framework.png\"\u003e\nFrom the picture, we know that it\u0026rsquo;s our job to implement TCP/IP in user layer in this class. But how do our packets of network send to other computers through the internet ? The answer is to use tun/tap device under the linux kernel. The tun/tap device is kinda like a software net-card which tun device gives you raw IP packet and tap device gives you raw MAC dataframe. And follow the instructions of the tun.sh, setting the iptables to route makes our packet to go elsewhere.\u003c/p\u003e","title":"cs144-lab4"},{"content":"TCP Sender Class TCP Sender Responsibility,\n• Keep track of the receiver’s window (receiving incoming TCPReceiverMessages with their acknos and window sizes) • Fill the window when possible, by reading from the ByteStream, creating new TCP segments (including SYN and FIN flags if needed), and sending them. The sender should keep sending segments until either the window is full or the outbound ByteStream has nothing more to send. while loop • Keep track of which segments have been sent but not yet acknowledged by the receiver— we call these “outstanding” segments . outstanding segments • Re-send outstanding segments if enough time passes since they were sent, and they haven’t been acknowledged yet. timer class design\nNotes to be reminded of.\nwhen started, we see window size of the peer is 1, so we can just send SYN bit. tick method, when it was called, it proves that how many time passed, we don\u0026rsquo;t have to use clock or time function when received a ackno, how to compare (Wrap32) Basic implementation of tcp sender class\npush method first , we need to keep track of the window size of the TCPreceivermessage, use member variable. The basic idea of the method is to fill the window as possible. In here, we need to judge the ByteStream bytes_buffered , TCPconfig:MAX_PAYLOAD_SIZE, and the window size. Note: the TCPconfig:MAX_PAYLOAD_SIZE is only used for payload.\nWhen there is no message received at all, we just need to send SYN bit only. And if the message is comming, we need to fill the window as soon as possible. After that, add FIN bit in the end. The FIN bit is sometimes nusty when i implement this function. I use a close_state to indicate the FIN state, if the FIN state is sent, we see the connection is closed.\nWhen the window size is zero, we need to transmit one bit to the peer.\nI use list to keep track of the outstanding segments, when each segment is sent, we add it into the list. Using list, we can iterate easily.\nreceive method Each time , we received a TCPReceivermessage, we have to compare the ackno (absolute seqno greater than). But the Wrap32 will wrap around sometimes, so we just use operator== to compare. In the list, operator== matches it will return the iterator, then we use erase to remove it. Actually we have to do some arithematic to solve it, but it doesn\u0026rsquo;t matter.\nBesides, we are supposed to update the this-\u0026gt;recv_message_ which tracks the window size and wind_zero attribute. It\u0026rsquo;s quite important, so we have to do it.\nmake_empty_message Actually i don\u0026rsquo;t fully know why to implement this function, but What i know is that set the right seqno will make it easy. So we need an another var to keep track of the bytes_len transmitted.\ntick The tick function is really nusty for me, at first, we have the RTO initial value, when the tick is called , it says that how many times passed, if the time expired which means the passed time is greater than initial RTO, we have to resend the lowest seqno, and check the window_size to decide whether we should double the RTO or not, last but not least add the consecutive_transmissions for one.\nI implemented a timer class to do it, when to start the timer, and when to reset. Each time we push a valid segment we need to start the timer. And each time we recv an ackno, we should decide whether to reset or not.\nBug Advice when use STL library, check the empty first will minus the time you debug. When a ADDRESS_SNIFFER came out in the debug, you should consider if we forget checking the STL library before operating the container.\nCorner Cases There are many corner cases to remind of, but i don\u0026rsquo;t wanna metion in this blog post. Finally after great efforts, I finally succeeded.\n","permalink":"http://localhost:1313/posts/cs144/lab3/","summary":"\u003ch2 id=\"tcp-sender-class\"\u003eTCP Sender Class\u003c/h2\u003e\n\u003cp\u003eTCP  Sender Responsibility,\u003c/p\u003e\n\u003cp\u003e• Keep track of the receiver’s window (receiving incoming TCPReceiverMessages with\ntheir acknos and window sizes)\n• Fill the window when possible, by reading from the ByteStream, creating new TCP\nsegments (including SYN and FIN flags if needed), and sending them. The sender should\nkeep sending segments until either the window is full or the outbound ByteStream has\nnothing more to send. \u003cstrong\u003ewhile loop\u003c/strong\u003e\n• Keep track of which segments have been sent but not yet acknowledged by the receiver—\nwe call these “outstanding” segments . \u003cstrong\u003eoutstanding segments\u003c/strong\u003e\n• Re-send outstanding segments if enough time passes since they were sent, and they\nhaven’t been acknowledged yet. \u003cstrong\u003etimer class design\u003c/strong\u003e\u003c/p\u003e","title":"cs144-lab3"},{"content":"Outline of TCPreceiver From the lab0, and lab1 we have implemented the ByteStream and Reassembler, in this lab2, I am gonna implement TCPreceiver.\nFirst of all, we have to illustrate , in TCP (transmition control protocol), there may be many cases of the packets sent by the tcp peer of sender(versus the contrary). For example, there may be lost, altered, reordered, duplicated. And the TCP protocol was designed to handle these cases , so did I.\nreordered (out-of-order) or duplicated We can use index(seqno) to avoid this case, just like we analysed in lab1 the checking conditions of reassembler . For example,\nString \u0026#34;abcdef\u0026#34; push(\u0026#34;ab\u0026#34;) push(\u0026#34;ab\u0026#34;, index:0) push(\u0026#34;ab\u0026#34;) push(\u0026#34;ab\u0026#34;, index:0) push(\u0026#34;abcd\u0026#34;) -----------\u0026gt;push(\u0026#34;abcd\u0026#34;, index:0) push(\u0026#34;f\u0026#34;) push(\u0026#34;f\u0026#34;, index:5) push(\u0026#34;e\u0026#34;) push(\u0026#34;e\u0026#34;, index:4) altered As we all know, the stack of service abstraction is like,\nshort gets(DNS, DHCP)-\u0026gt;User datagrams-\u0026gt;Internet Datagrams Byte Stream(TCP) -\u0026gt;User datagrams -\u0026gt;Internet Datagrams \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-Web requests/responses(HTTP)-\u0026gt;Byte Stream \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;Youtube/wikipedia-\u0026gt; Web requests/responses \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-Email sending(SMTP)-\u0026gt;Byte Stream \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-Email receiving(IMTP)-\u0026gt;Byte Stream In the OSI model or industrial network model, the TCP will use IP protocol to send message or receive, and the IP has a checksum for check-up when the packets receive, it will drop it off if the packets are not right enough. So we the bytestream altered, the IP protocol will help us to drop it and handle this case.\nmissing or lost Like UDP, we can\u0026rsquo;t retransmit the message over and over again until we got the answer. So we have to use another method to handle this case. Acknolegement.\nByte String \u0026#34;A B C D E F G FIN\u0026#34; FIN indicates end of the string. Sender: Receiver: \u0026#34;A index:0\u0026#34; \u0026#34;B index:1\u0026#34; \u0026#34;C index:2\u0026#34; \u0026#34;D index:3\u0026#34; missing in the trip \u0026#34;E index:4\u0026#34; \u0026#34;F index:5\u0026#34; \u0026#34;G index:6\u0026#34; \u0026#34;FIN index:7\u0026#34; {ack:3} we assume that, the network area of sender is fast than receiver. That is why sender sends all messages before receiver receives. The receiver gives ack 3 means that, index 0 1 2 are received in the stream, next we need index 3. Note, we have to give FIN a number, when the ack 8 means we received FIN which can be an notion for the sender that it\u0026rsquo;s time to close the connection. However, is it enough? TCP is a flow-control protocol, the practical recv message is \u0026lt;ackno: \u0026lt;\u0026gt;, window_size: \u0026lt;\u0026gt; \u0026gt; which tells the sender the size of slide-window. In some situations, the window-size is far more meaningful.\nImplemention of Class In this lab2, the outline of the TCP receiver is like, Note: rule of TCP reply to any nonempty message.(which i haven\u0026rsquo;t noticed that until i implented the class of tcp receiver).\nend of stream And if the a sender has ended the stream, maybe the incoming bytes has not received yet. So the peer of the sender of TCP may not be closed. But at the same time, another connection has built used the same port number of the sender, and the last peer of sender will send the last packet, it will casue conflit with the new built sender.\nTo handle this we use a random big number as start of ISN (initial sequence number) + SYN to indicates the seqno, which can diminish the conflits. But in RFC of TCP header, the seqno is 32 bit, as the seqno grows it will wrap around to zero, so we have to do some arithemtics to handle this meric.\nNote: the first seqno is to SYN, and the last seqno is FIN. So we should acknolege each of them.\nThree-way-handshake without SYN and seqno: - I: {{first_index=0, data=”abcdef”, FIN=true}, {next_needed=0, window_size=1000}} - Peer: {{first_index=0, data=””, FIN=true}, {next_needed=7, window_size=1000}} - I: {{first_index=7, data=””, FIN=false}, {next_needed=1, window_size=1000}} no end of the stream, and the peer mistakes that the sender need to bytes from it. the next_needed sometimes will misunderstand the peer I think. with SYN: - I: {{seqno=12340, SYN=true, data=”abcdef”, FIN=true}, {What should this be? (before seeing 9999 from the Peer)}} - Peer: {{seqno=9999, SYN=true, data=””, FIN=true}, {next_needed=12348, window_size=1000}} - I: {{next_needed=10001, window size =1000}} That\u0026#39;s why we need a state ack to inform the peer of direction of bytestream. upgrade ACK \u0026lt;ACK flag, ackno\u0026gt;: - I: {{seqno=12340, SYN=true, data=”abcdef”, FIN=true}, {ACK=false, ackno={missing}, window_size=1000}} (SYN) - Peer: {{seqno=9999, SYN=true, data=””, FIN=true}, {ACK=true, ackno=12348, window_size=1000}} (SYN+ACK) - I: {{ACK=true, ackno=10001, window size =1000}} (ACK) This is three way handshake of TCP(SYN+SYN-ACK+ACK). Wrap and Unwrap From above, we know seqno is 32bit which will wrap around, for the UINT32_MAX is limited in network transmition. So we need to transfrom index from one to another.Here is the index table which represents the relationship between all of them. Wrap implemention like this.\n// ( SYN + n ) mod 2^32 return Wrap32 { zero_point + static_cast\u0026lt;uint32_t\u0026gt;(n)}; And Unwrap is kind of noying, that is because when given a number like 15, if the ISN is zero, the absolute index might be 15 , 15 + 2^32, 15 + 2^33, .etc. That\u0026rsquo;s why we need another checkpoint index closest near it to help find out the right index.\nuint64_t Wrap32::unwrap( Wrap32 zero_point, uint64_t checkpoint ) const { // SYN: 2^32 -2 this-\u0026gt;raw_value_; // seqno 2 // absolute seqno 2^32 + 4 uint32_t off = this-\u0026gt;raw_value_ - zero_point.raw_value_; if(this-\u0026gt;operator==(zero_point)){ // 0 , 2^32 , 2^33 .etc // [(checkpoint \u0026gt;\u0026gt; 32 \u0026lt;\u0026lt; 32 ) , (checkpoint \u0026gt;\u0026gt; 32 + 1) \u0026lt;\u0026lt; 32] // checkpoint \u0026gt;\u0026gt; 31 bool last = checkpoint \u0026amp; 0x0000000080000000; return (1UL \u0026lt;\u0026lt; 32) * ((checkpoint \u0026gt;\u0026gt; 32) + last); }else{ if(checkpoint \u0026lt;= off) return off; bool last = ( checkpoint - off )\u0026amp; 0x0000000080000000; return (1UL \u0026lt;\u0026lt; 32) * (((checkpoint - off) \u0026gt;\u0026gt; 32 ) + last)+ off; } } seqno equals to zero_point(ISN) This condition is simple, because it is not 0, or 2^32, or multiples of 2^32 which is near to checkpoint. And the way to get the nearest index is to find checkpoint is above or below the middle of the two.\n|--------|------------------| 2^(32+n-1) checkpoint 2^(32+n) we use checkpoint\u0026gt;\u0026gt;31 maybe 0x11 that\u0026#39;s above middle or 0x10, that\u0026#39;s below middle. use 31 not 32 to indicates the above or below middle which is helpful.(I dbg the tests finding that connection). seqno not equals to zero_point(ISN) we subtract an offset and still use the method above. And if you say off is minus zero, yes that\u0026rsquo;s true, and the unsigned will wrap it to plus value. Note: the minimum is off if the checkpoint is less than off. TCP Receiver Class keep track of start I use a class private var to track it, when it is true to insert substrings into the reassembler.\nindex calculate absolute index and real payload index in assembler.\n// Push any Data into the Reassembler uint64_t seqno = message.seqno.unwrap(this-\u0026gt;isn, this-\u0026gt;reassembler().unassembled_index()); // insert index starts from zero and pointed by payload this-\u0026gt;reassembler_.insert(message.SYN + seqno - 1, message.payload, message.FIN); send message Rule: TCP will reply any nonempty message. and we need to check whether the state_s is true or false to indicate the ack flag, and ackno is next_indexed(which is offered by reassembler ). RST state need to be designed when the bytestream has an error(the ByteStream has had this api provided).\nTCPReceiverMessage TCPReceiver::send() const { uint64_t win_size = this-\u0026gt;writer().available_capacity(); tcp_m.window_size = win_size \u0026gt;= UINT16_MAX ? UINT16_MAX : win_size; // to avoid overflow // unassembled_index + 1 (SYN must accept it) + FIN(may be not ending state so we use function of reassemble_connect_state to represent it) tcp_m.ackno = state_s ? ack.wrap(this-\u0026gt;reassembler_.unassembled_index() + 1 + this-\u0026gt;reassembler().reassemble_connect_state(), this-\u0026gt;isn) : std::optional\u0026lt;Wrap32\u0026gt;{}; tcp_m.RST = this-\u0026gt;reader().has_error(); return tcp_m; } Last but not least, Window size is 16 bits, when the capacity of bytestream is up to or above this limit, we must do some check to avoid this overflow when assignment.\nFinally, successfully passed the tests. ","permalink":"http://localhost:1313/posts/cs144/lab2/","summary":"\u003ch2 id=\"outline-of-tcpreceiver\"\u003eOutline of TCPreceiver\u003c/h2\u003e\n\u003cp\u003eFrom the lab0, and lab1 we have implemented the ByteStream and Reassembler, in this lab2, I am gonna implement TCPreceiver.\u003c/p\u003e\n\u003cp\u003eFirst of all, we have to illustrate , in TCP (transmition control protocol), there may be many cases of the packets sent by the tcp peer of sender(versus the contrary). For example, there may be lost, altered, reordered, duplicated. And the TCP protocol was designed to handle these cases , so did I.\u003c/p\u003e","title":"cs144-lab2"},{"content":"Overview Course Learn operations idempotency meaning:\nIdempotency is a property of certain operations or API requests that ensures performing the operation multiple times yields the same result as if it were executed only once. (GET PUT) And the result we expect is result form not result value.\nA non-idempotent operation, on the other hand, changes the state with each execution, meaning that subsequent calls with the same input can yield different results. This is crucial to recognize because it can lead to unintended side effects when such operations are repeated. (POST)\nshort packets data can be\nlost reorder alter duplicate line of code From the startup code, i used almost 122 lines of code to design ByteStream in lab0 which is larger than TA in class - 82 lines of code.\nhow to run this scripts ?\n$ sudo apt install slocount $ ./scripts/lines-of-code ; in mindow directory ByteStream: 122 lines of code Reassembler: 26 lines of code $ ByteStream: 82 lines of code Reassembler: 26 lines of code TCP Receiver In this assignment , what you\u0026rsquo;re gonna do is to rearrage the bytestream form unreliable to reliable and then to offer to the Socket that can be read by the web-application like webget, etc.\nwhy do this ?\nTCP robustness against reordering and duplication comes form its ability to stitch arbitrary excerpts of the byte stream back into the original stream. Implementing this in a discrete testable module will make handling incoming segments easier.\nIncoming Substring normal format \u0026#34;abcdefghaaa\u0026#34; {index: 0, \u0026#34;abcd\u0026#34;} {index: 4, \u0026#34;efg\u0026#34;} {index: 7, \u0026#34;ha\u0026#34;} {index: 9, \u0026#34;aa\u0026#34;, last_string: ture} or \u0026#34;zyyll\u0026#34; {index: 0, \u0026#34;z\u0026#34;} {index: 0, \u0026#34;zyy\u0026#34;} {index: 3, \u0026#34;ll\u0026#34;, last_string: true} .etc. your Reassember module should handle many corner cases like lost, duplicate, altered, and reordered.\nOutline of Reassember Class The whole incoming substring construct format is like this. code procedure step 1. check whether the incoming substring can be put into Bytestream or not? From the picture, we know that the incoming string\u0026rsquo;s index should not lie beyond first unaccepted index. And, similarly an duplicated substring which doesn\u0026rsquo;t exceed the first_unassembled_index is not allowed to put into the bytestream module. So the conditions are like this below.\n// Step1. discard message for duplicate and lie beyond size uint64_t avi = this-\u0026gt;writer().available_capacity(); uint64_t pos = 0; uint64_t cnt = 0; if(first_index \u0026gt; next_index + avi) return; // lie beyond if(first_index + data.size() \u0026lt;= next_index){ if(is_last_substring) // corner case like emtpy string \u0026#34;\u0026#34; and close this-\u0026gt;output_.writer().close(); return; // duplicate } if(first_index + data.size() \u0026gt; next_index + avi){ // not fully lie beyond but we need to doc the state of temp // update the beyond_ if(is_last_substring){ // need to check beyond_index = first_index + data.size(); nclose_state = true; } // |-----| // |-----| // [pos, cnt] cnt = first_index + data.size() - next_index -avi; pos = data.size() - cnt; data.erase(pos, cnt); } step 2. substrings can be put or assembled the incoming substring can be like in the picture below. if the substring covers the next_index, we have to put into the Bytestream, if not we have to put into the reassember internal storage. To simplify the reassembler class, i chose std::unordered_map\u0026lt;uint64_t, std::stirng\u0026gt; as the internal storage for reassember, that\u0026rsquo;s because we can find and iterate it fast.\n// two conditions like 1). repeat send but large enough , then need to be merged // 2). not sequenced needed to be put in map_ , then need to be merged if(first_index \u0026lt;= next_index){ // |-----| // |-----| pos = 0; cnt = next_index - first_index; data.erase(pos, cnt); this-\u0026gt;output_.writer().push(data); // update next_index; next_index += data.size(); // then check if need to merge and push auto it = find_next_assembly(next_index); while(it != map_.end() \u0026amp;\u0026amp; map_.size() \u0026gt; 0){ pos = 0; cnt = next_index - it-\u0026gt;first; it-\u0026gt;second.erase(pos, cnt); this-\u0026gt;output_.writer().push(it-\u0026gt;second); next_index += it-\u0026gt;second.size(); map_.erase(it); it = find_next_assembly(next_index); } // |-----| pushed // |---| pending // do some clear this-\u0026gt;unassmbly_clear(next_index); } When I put the substring in the bytestream module, we have to think over whether there are other unassembled strings can be merged. The function find_next_assembly is the way to find one, I choose while loop structure to merge that.\nLast but not least, I need do some clear in case that while-loop finds nothing to merge but need to discard like\n// |-----| pushed // |---| pending // do some clear step3, string that put into the internal storage of reassembler Well, strings that put into the map_ might also be merged in some cases, like the string cover the one in map_, or the string can splice with another one in the map_. there are many cases we can think of, but only two conditions can handle these cases. So we need to check which one it is , and if not just insert into the internal storage.\nHere are the two conditions. And the code implementation is just like do the left check loop until merged, after that do the same thing as the right loop check. And if the program runs out of the two loop, we can figure it out that this string need not be merged and just put into the map_.\nvoid Reassembler::merge_unassembly_map(uint64_t index, std::string data){ // Condition 1. find left auto it_left = find_merge_left(map_, index, data); uint64_t cnt = 0; uint64_t pos = 0; uint64_t i = 0; while(it_left != map_.end()){ if(index + data.size() \u0026gt;= it_left-\u0026gt;first + it_left-\u0026gt;second.size()){ map_.erase(it_left); map_.insert({index, data}); }else{ if(index == it_left-\u0026gt;first){ //do nothing break; }else{ cnt = it_left-\u0026gt;first + it_left-\u0026gt;second.size() - index - data.size(); pos = it_left-\u0026gt;second.size() - cnt; for(i = 0; i \u0026lt; cnt; i++) data.push_back(it_left-\u0026gt;second[pos + i]); map_.erase(it_left); map_.insert({index, data}); } } it_left = find_merge_left(map_, index, data); } auto it_right = find_merge_right(map_, index, data); while(it_right != map_.end()){ if(index + data.size() \u0026lt;= it_right-\u0026gt;first + it_right-\u0026gt;second.size()){ // do nothing return; }else{ cnt = index + data.size() - it_right-\u0026gt;first - it_right-\u0026gt;second.size(); pos = data.size() - cnt; for(i = 0; i \u0026lt; cnt; i++){ it_right-\u0026gt;second.push_back(data[pos+i]); } // to avoid the index is in the map if(index != it_right-\u0026gt;first){ it_right = map_.find(index); if(it_right != map_.end()) map_.erase(it_right); } return; } it_right = find_merge_right(map_, index, data); } // map_.insert({index, data}); return; } corner case \u0026ldquo;bz\u0026rdquo;, index 1, is last string ture; capacity = 1\nthis case demostrates that, the last string has come first. But we don\u0026rsquo;t have too much room to put into the internal storage. So we need to do some check and handle this case. In my mind, I choose to document the beyond_index it finally reaches. So when everythings works fine, i have to check if the beyond_index equals the next_index or not in the last.\nif(is_last_substring){ close_state = true; } if(!nclose_state){ beyond_index = next_index; } if(close_state \u0026amp;\u0026amp; map_.size() == 0 \u0026amp;\u0026amp; beyond_index == next_index){ this-\u0026gt;output_.writer().close(); } return; line of code ./scripts/lines-of-code ByteStream: 122 lines of code Reassembler: 176 lines of code Lastly, i passed the tests, but the codes i wrote are a little bit clumsy. I will implement and upgrade this class module in the future to make it easy to use.\n","permalink":"http://localhost:1313/posts/cs144/lab1/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003ch3 id=\"course-learn\"\u003eCourse Learn\u003c/h3\u003e\n\u003cp\u003eoperations idempotency meaning:\u003c/p\u003e\n\u003cp\u003eIdempotency is a property of certain operations or API requests that ensures performing the operation multiple times yields the same result as if it were executed only once. (GET PUT)\nAnd the result we expect is \u003cstrong\u003eresult form\u003c/strong\u003e not \u003cstrong\u003eresult value\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA non-idempotent operation, on the other hand, changes the state with each execution, meaning that subsequent calls with the same input can yield different results. This is crucial to recognize because it can lead to unintended side effects when such operations are repeated. (POST)\u003c/p\u003e","title":"cs144-lab1"},{"content":"1 Set up Linux environment ubuntu 22.04 g++ 11.4 packages required $ sudo apt update \u0026amp;\u0026amp; sudo apt install git cmake gdb build-essential clang \\ clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark 2 Networking by hand networking abstraction \u0026mdash;reliable bidirectional byte stream\n2.1 Fetch a Web Page steps web server address using telnet telnet cs144.keithw.org http to open a reliable byte stream between two computers. First, Type GET /hello HTTP/1.1 `Enter` the Enter is very important Second, Type Host: cs144.keithw.org `Enter` Third, Type Connection: close `Enter`` Finally, Type `Enter` explanation \u0026mdash;\u0026mdash;\u0026ndash; http://host/path\nGET tells the path part of the URL Host tells the host part of the URL close tells the server you finished the request the last `Enter`tells the server you are done with the HTTP request After that the result is as such. 2.2 Send yourself an email send an email massage using a reliable byte stream to a service running on another computer I use 163-netease email to do this job for I am not standford student.These steps are introduced as follows:\ngo to the setting of the 163-email to enable smtp server Then using telnet to construct a connection between two computers `telnet smtp.163.com smtp` or `telnet smtp.163.com 25` where port `25` is the smtp server port number Type `HELO hello.victor` `Enter` it will echo `250 OK` the response code number starts with 2xx or 3xx is great to indicate connection is right! But when the response code number is 5xx, it tells you that something was wrong. Type `EHLO hello.victor` it will print it out something you need to do to authentication. After that, you need to login in by type `AUTH LOGIN` , when you do that, you have to type base64 coded you user name and vertification code.base64 converter This page will help you to do so, last but no least you have to set you own vertification code in your 163-email website. When authentication is successfully, you are allowed to send an email. as you can see from the picture, after authentication, we can send email from byte stream by typing `MAIL FROM:` and `RCPT TO:`, don\u0026rsquo;t forget to add an `\u0026lt;\u0026gt;`around your email address. When you type Data, you have to leave a blank line at the end of the headers. When finished the body, type `Enter`to end this edit. With all things done, type `quit` to end the conversation with the email.\ntelnet: a client that makes outgoing connection with programs running on other computers. Let\u0026rsquo;s to be a simple server, which is kind of program that waits around for clients to connect it.\n2.3 Listening and connecting The netcat command `v` to produce more verbose output, and `-l` to listening a port and `-p` to designate port number 9090, the telnet to connect this server, which localhost indicates the same ip address shared each other. This picture indicates this communication.\n3 Writing a network program using an OS stream socket we are gonna to use the feature provided by operating system (Linux) that the ability to create a reliable bidirectional byte stream between two commputers.\u0026mdash;- Stream Socket\n3.1 webget TCPSocket Class - in mindow project, the socket class lib is wrapped around using C++ and can be called from C code.\nTCPSocket Class inheritance relationship\nthis image shows up the inheritance relationship.\nFileDescriptor Class\ncopy/move constructor and assignment Copy Constructor Ref Detail\nA copy constructor is a constructor which can be called with an argument of the same class type and copies the content of the argument without mutating the argument.\nargument list must satisfy all following conditions\ngiven the class type T, the argument list must be a reference of T it will be T\u0026amp;, const T \u0026amp;, volatile T\u0026amp;, const volatile T\u0026amp; note: it can have multiple args but at least ref of class in it.\nWhen copy constructor is called?\ninitialization T a = b; T a(b); where b is class of T. function arg passing void f(T a). function return value, which has no move constructor. T f(){ return a} Copy Assignment Ref Detail\nargument list must satisfy all following conditions\ngiven the class type T, the argument list must be a reference of T and T it will be T, T\u0026amp;, const T \u0026amp;, volatile T\u0026amp;, const volatile T\u0026amp; note: it must have one argument.\nWhen to call the copy assignment?\nThe copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression.\nlike: f1 = f2; operator= is selected when overload resoluting.\nMove Constructor Ref Detail\nargument list must satisfy all following conditions\ngiven the class type T, the argument list must be \u0026amp;\u0026amp; like. it will be T\u0026amp;\u0026amp;, const T \u0026amp;\u0026amp;, volatile T\u0026amp;\u0026amp;, const volatile T\u0026amp;\u0026amp;. When to call the move constructor?\ninitialization like T a = std::move(b) argument passing f(std::move(a) return type like return a T f() Move Assignment Ref Detail\nlike a = std::move(a2) The copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression.\n// An FDWrapper cannot be copied or moved FDWrapper( const FDWrapper\u0026amp; other ) = delete; // copy constructor FDWrapper\u0026amp; operator=( const FDWrapper\u0026amp; other ) = delete; // copy assignment FDWrapper( FDWrapper\u0026amp;\u0026amp; other ) = delete; // move constructor FDWrapper\u0026amp; operator=( FDWrapper\u0026amp;\u0026amp; other ) = delete; // move assignment webget sequence the sequence of tcp connect is like this..\nconstruct TCPSocket\nconstruct Address\nconnect\nwrite buffer to get url page\nwait to read like string operation\nall these functions will call CheckSystemCall and then unix_error will call kernel api like socket connect and or so.\nclass unix_error : public tagged_error { public: explicit unix_error( const std::string_view s_attempt, const int s_errno = errno ) : tagged_error( std::system_category(), s_attempt, s_errno ) {} }; 3.2 byte stream In this section I will implement a pipe like byte stream, which a Writer puts data into the pipe and the Reader pops it.\nAfter reading the check0.pdf, I firstly choose string as a ring buffer.\ncompile error and run error\n$ cmake --build build --target check0 it will print out this message like that infinitely. AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL After that I search from StackOverflow, it turns out that the linux setting is not suitable for clang. The solution for this is\n$sudo sysctl vm.mmap_rhd_bits=28(check the value by sudo sysctl vm.mmap_rhd_bits) after reboot this change will disappear. And if I wanna pernament change this setting, I have to change the etc file of /etc/sysctl.conf add `vm.mmap_rhd_bits=28` in this file $sudo sysctl -p if not just reboot std::string_view\nThe std::string_view class I don\u0026rsquo;t fully understand, so I failed in peek tests. That is a ring buffer is wrapped around when start and end pointers are not equal, and string_view class needs a sequence char in memory. So i fail in the peek tests.\nAfter that, I switch to deque/queue. In this way, I passed 7 tests, but stuck in 8 peek tests, it says that heap buffer overflow when I didn\u0026rsquo;t use gdb in eshell. The reason why i got this error is still string_view needs a sequence capture char in memory. And deque/queue implementation is chunks of memory linked, each set of memory is in sequence but not all the items. I use gdb to prove that. From the picture, we can see that the deque has discontinuous memory address the same as queue, that\u0026rsquo;s why I get this error for several days to handle.\nThen I switched to list vector as my pipe container. Everything works great, except that string_view must constructs with continuous iterator, we all knew that linked-list has discontinous items when inset and remove.\nThe final approach to handle peek function is use another string whenever I push or pop from the pipe I always rearrange the pipe so that it is in sequential memory using copy method.\nvoid Writer::push( string data ) { // ........ // reflush the pipe_view after each push and pop if(pipe_e \u0026gt; pipe_s){ pipe_.copy(\u0026amp;pipe_view[0], pipe_.size(), pipe_s); }else{ pipe_.copy(\u0026amp;pipe_view[0], capacity_ - pipe_s, pipe_s); pipe_.copy(\u0026amp;pipe_view[capacity_ - pipe_s], pipe_e, 0); } } void Reader::pop( uint64_t len ) { // .... // reflush the pipe_view after each push and pop if(pipe_e \u0026gt; pipe_s){ pipe_.copy(\u0026amp;pipe_view[0], pipe_.size(), pipe_s); }else{ pipe_.copy(\u0026amp;pipe_view[0], capacity_ - pipe_s, pipe_s); pipe_.copy(\u0026amp;pipe_view[capacity_ - pipe_s], pipe_e, 0); } } and if I do some changes in Peek function it will cause compilation error like that.\nerror: invalid conversion from ‘const __gnu_cxx::__alloc_traits\u0026lt;std::allocator\u0026lt;char\u0026gt;, char\u0026gt;::value_type*’ {aka ‘const char*’} to ‘char*’ [-fpermissive] That is because Peek function is a const member function which has no right to change the member value.\nAfter adopting this way, I finally successfully passed the tests, though the speed is not so fast but i give in my efforts. There are a lot of efforts to take to make the code looks great and faster. I will do it in the future. ","permalink":"http://localhost:1313/posts/cs144/lab0/","summary":"\u003ch2 id=\"1-set-up-linux-environment\"\u003e1 Set up Linux environment\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eubuntu 22.04\u003c/li\u003e\n\u003cli\u003eg++ 11.4\u003c/li\u003e\n\u003cli\u003epackages required\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e $ sudo apt update \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo apt install git cmake gdb build-essential clang \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003eclang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"2-networking-by-hand\"\u003e2 Networking by hand\u003c/h2\u003e\n\u003cp\u003enetworking abstraction        \u0026mdash;reliable bidirectional byte stream\u003c/p\u003e\n\u003ch3 id=\"2-dot-1-fetch-a-web-page\"\u003e2.1 Fetch a Web Page\u003c/h3\u003e\n\u003ch4 id=\"steps\"\u003esteps\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://cs144.keithw.org/hello\"\u003eweb server address\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eusing telnet \u003cstrong\u003etelnet cs144.keithw.org http\u003c/strong\u003e to open a reliable byte stream between two computers.\u003c/li\u003e\n\u003cli\u003eFirst, Type \u003cstrong\u003eGET /hello HTTP/1.1\u003c/strong\u003e `Enter` the Enter is very important\u003c/li\u003e\n\u003cli\u003eSecond, Type \u003cstrong\u003eHost: cs144.keithw.org\u003c/strong\u003e `Enter`\u003c/li\u003e\n\u003cli\u003eThird, Type \u003cstrong\u003eConnection: close\u003c/strong\u003e `Enter``\u003c/li\u003e\n\u003cli\u003eFinally, Type `Enter`\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"explanation\"\u003eexplanation\u003c/h4\u003e\n\u003cp\u003e\u0026mdash;\u0026mdash;\u0026ndash; \u003cstrong\u003e\u003ca href=\"http://host/path\"\u003ehttp://host/path\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"cs144-lab0"}]