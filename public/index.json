[{"content":"C-plus-plus profile object object based -class without pointer members -Complex -class with pointer members -String object oriented -inheritance -composition -delegation data and functions C type[data] [functions]\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt;variable in memory C++ class/struct [data, functions]\u0026mdash;\u0026mdash;\u0026gt;object in memory Note: the function of class only has one copy which means when you create class only data occupies memory and vptr (if has virtual function inside class).\nC-plus-plus coding program .h/.cpp/.hpp never mind\ngurad declaration #progam once // #ifndef __COMPLEX__ #define __COMPLEX__ #endif Header Layout class-delcaration class complex { } class-definition complex::function ... ... forward-declarations class complex; template complex not only double real and image, maybe float or int\ntemplate\u0026lt;typename T\u0026gt; class complex { private: T re, ra; } complex\u0026lt;int\u0026gt; c1; complex\u0026lt;double\u0026gt; c1; inline when you define a function in class body\nclass complex { public: complex (double r= 0, double i= 0) : re(r), im(i) {} complex\u0026amp; operator+=(const complex\u0026amp;); double real() const{return re;} double imag() const{return im;} private: double re, ra; friend complex\u0026amp; __doapl (complex*, const complex\u0026amp;); } The real/imag function will be canditate for inline functions automatically.Btw, the way it becomes inline function depends on the complier and the complexity of the function itself.\nConstructor function (ctor) access level public protected ( in which I don\u0026rsquo;t give it to public interface and differs from private function , I can use it) protected example in 8_virtual_polymorphism.org file. private are not allowed by outside of the class\nclass complex { public: complex (double r= 0, double i= 0) : re(r), im(i) {} complex\u0026amp; operator+=(const complex\u0026amp;); double real() const{return re;} double imag() const{return im;} private: double re, im; friend complex\u0026amp; __doapl (complex*, const complex\u0026amp;); } .... complex c1(2,1); cout \u0026lt;\u0026lt; c1.re; //not allowed cout \u0026lt;\u0026lt; c1.im; //not allowed complex c1(2,1); cout \u0026lt;\u0026lt; c1.real(); cout \u0026lt;\u0026lt; c1.imag(); constructor (ctor) function name is class no return type default argument initialization list ( assignment not advised) public: complex (double r= 0, double i= 0) : re(r), im(i) {} initialization stage:\ninitialization :re(r), im(i) assignment when you use assignment to initialize private variable, it is allowed but low-efficiency\npublic: complex (double r= 0, double i= 0) { re = r; im = i;} ctor function overloading That means ctor has multiple forms, actually the overloading function has different name viewed by compiler.\nvoid real(double r ) {re = r;} viewed by compiler, ?real@Complex@@QBENXZ ?real@Complex@@QAENABN@Z however, when you define two ctor functions.\nclass complex { public: complex (double r= 0, double i= 0) : re(r), im(i) {} complex () : re(0), im(0) {} ... complex c1; complex c2(); These two functions are not allowed, that is because the compiler doesn\u0026rsquo;t deccide which one to call when construct c1 and c2, i mean both the ctor functions are ok to called. It is defined ok but called error, and it will print messages like that below.\ncomplex_test.cpp:14:11: error: call of overloaded ‘complex()’ is ambiguous 14 | complex c1; | ^~ In file included from complex_test.cpp:2: complex.h:17:3: note: candidate: ‘complex::complex()’ 17 | complex (): re (0), im (0) { } | ^~~~~~~ complex.h:16:3: note: candidate: ‘complex::complex(double, double)’ 16 | complex (double r = 0, double i = 0): re (r), im (i) { } brace initialization In the last example above, if you use complex c2(); to declare an object, the compiler will think it might be a function declaration or object declaration which confuses the compiler. So, if you wanna use default ctor you can remove the (), or change it to {} braces. complex c2{}; complex c2;\ncomplex_test.cpp:14:13: warning: empty parentheses were disambiguated as a function declaration [-Wvexing-parse] 14 | complex c2(); | ^~ complex_test.cpp:14:13: note: remove parentheses to default-initialize a variable 14 | complex c2(); | ^~ | -- complex_test.cpp:14:13: note: or replace parentheses with braces to value-initialize a variable private ctor Singleton - design pattern, means just only one instance of a class.\nclass A{ public: static A\u0026amp; getInstance(); setup() { ... } private: A(); A(const A\u0026amp; rhs); ... }; static A\u0026amp; A::getInstance(){ static A a; return a; } ... A::getInstance().setup(); const member function Advice: member function\nmight change the private value might not change the private value The function which not change the private value need to add const identifier. The position of const need to add after the ) before the { symbol\ndouble real() const{return re;} double imag() const{return im;} double real() {return re;} double imag() {return im;} // example { const complex c1(2,1) cout \u0026lt;\u0026lt; c1.real(); // error conflict! cout \u0026lt;\u0026lt; c1.imag(); } ","permalink":"http://localhost:1313/posts/c++_basic/1_ctor/","summary":"\u003ch2 id=\"c-plus-plus-profile\"\u003eC-plus-plus profile\u003c/h2\u003e\n\u003ch3 id=\"object\"\u003eobject\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eobject based\n-class without pointer members\n-Complex\n-class with pointer members\n-String\u003c/li\u003e\n\u003cli\u003eobject oriented\n-inheritance\n-composition\n-delegation\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"data-and-functions\"\u003edata and functions\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eC type[data] [functions]\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt;variable in memory\u003c/li\u003e\n\u003cli\u003eC++ class/struct [data, functions]\u0026mdash;\u0026mdash;\u0026gt;object in memory\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote: the function of class only has one copy which means when you create class only data occupies memory and vptr (if has virtual function inside class).\u003c/p\u003e\n\u003ch3 id=\"c-plus-plus-coding-program\"\u003eC-plus-plus coding program\u003c/h3\u003e\n\u003cp\u003e.h/.cpp/.hpp never mind\u003c/p\u003e\n\u003ch3 id=\"gurad-declaration\"\u003egurad declaration\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#progam once\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e//\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#ifndef __COMPLEX__\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#define __COMPLEX__\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#endif\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"header-layout\"\u003eHeader Layout\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eclass-delcaration\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecomplex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col\u003e\n\u003cli\u003eclass-definition\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomplex\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003efunction ... ...\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col\u003e\n\u003cli\u003eforward-declarations\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecomplex\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"template\"\u003etemplate\u003c/h3\u003e\n\u003cp\u003ecomplex not only double real and image, maybe float or int\u003c/p\u003e","title":"1-basic-ctor-object-oriented-cpp"},{"content":"Object In this lab5, I am gonna to implent an IP interface for TCP/IP stack and IP router later in lab6. The IP interface is used to send etherframe using payload from IP layer. So, in this layer, we handle the mac etherframe in details. If we don\u0026rsquo;t konw the mac address of the next-hop IP address, we need to send ARP request to this subnet, then queuing the datagram until the ARP message received. After receiving the ARP message, we need to doc the \u0026lt;next-hop, mac\u0026gt; pair mapping for 30 secs in this lab, with this mapping, the next time sending to the same ip would not send ARP message again.\nThe most important thing we need to know that, the ARP protocol is based on the etherframe (aka MAC layer), which in another words to say, the ARP message is the payload of the etherframe except that it has special meaning of each field of the bytes.\nOk, Let\u0026rsquo;s see the ARP (address resolution protocol) in wiki. it says that ARP enables a host to send an IPv4 packet to another node in the local network by providing a protocol to get the MAC address associated with an IP address. The host broadcasts a request containing the node\u0026rsquo;s IP address, and the node with that IP address replies with its MAC addres Note: its message are directly encapsulated by a link layer protocol like MAC, and it is communicated within the boundaries of a single subnet and is never routed.\nARP packet structure I use an image from wiki to illustrate the structure of ARP message. Hardware Type ( HTYPE ):16 bits it specifys that which network link protocol type, use 1 indicates ethernet(MAC). Protocol Type ( PTYPE ): 16 bits This field specifys the internet protocol for which the ARP request is intended. Like IPV4 the value of this field is 0x0800. Hardware Length( HLEN ): 8 bits Length for Hardware type address, for ethernet is 6. Protocol Length (PLEN): 8 bits Length for Protocol address, for ipv4 is 4. Operation (OPER): 16 bits specifys the option of the sending, 1 for request 2 for reply. Sender Hardware Address (SHA): 48bits Media address of the sender. In an ARP request this field is used to indicate the address of the host sending the request. In an ARP reply this field is used to indicate the address of the host that the request was looking for. Sender Protocol Address (SPA): 32bits Internetwork address of the sender. Target Hardware Addres (THA): 48bits Media address of the intended receiver. In an ARP request this field is ignored. In an ARP reply this field is used to indicate the address of the host that originated the ARP request. Target Protocol Address(TPA): 32 bits Internetwork address of the intended reciever. Broadcast ARP message If we don\u0026rsquo;t the next-hop ethernet address, we need to send an ARP message to broadcast within the subnet. Here is the ARP message, assuming that the next-hop ip address is 192.168.0.1, our ethernet address is 48:32:12:98:78:90, our ip address is 4.3.2.1 I use an image to show the ARP message below. And the ARP message is within in etherframe, so the ARP message occupies the payload of the etherframe. The src is 48:32:12:98:78:90, and dst is ff:ff:ff:ff:ff:ff, which indicates a broadcast message.After that, we can just send the message to the subnet\nnetwork_interface structure of class we use linked-list as our main structure to handle the mapping and no-nexthop ip dgram.\nstruct ip_mac_map { // cache mapping IP-\u0026gt;MAC uint32_t ip; EthernetAddress mac; size_t ms_tick; }; struct dgram_no_mac { InternetDatagram dgm; uint32_t next_hop; size_t ms_tick; }; In this lab, each item of the list has a ms_tick to handle whether or not this mapping is valid and whether or not drop the dgram without nexthop ethernet address. The function tick method is just to update the mapping in the list file, if some of each exceeds 30 secs we drop it out, but be careful of erase list when iterating. Also it has the ability to decide whether or not drop the dgram in the no-mac dgram. Actually we don\u0026rsquo;t want to flood the network using ARP message repeatedly, so we need to check if the message we will send has the same ip as item in the no-mac linked list, and the item exists for less than 5 secs, we don\u0026rsquo;t send our arp message again, just queue or drop. (I didn\u0026rsquo;t handle that)\nwhy not queue? If i push staff for without no-mac of the nexthop, the next time arp message received, it might not be the first item pushed, and the queue can\u0026rsquo;t take out the second but only the head. That\u0026rsquo;s why I choose list to implent this.\nActually this lab is not hard, and there are also some cases to handle in the future. ","permalink":"http://localhost:1313/posts/cs144/lab5/","summary":"\u003ch2 id=\"object\"\u003eObject\u003c/h2\u003e\n\u003cp\u003eIn this lab5, I am gonna to implent an IP interface for TCP/IP stack and IP router later in lab6. The IP interface is used to send etherframe using payload from IP layer. So, in this layer, we handle the mac etherframe in details. If we don\u0026rsquo;t konw the mac address of the next-hop IP address, we need to  send ARP request to this subnet, then queuing the datagram until the ARP message received. After receiving the ARP message, we need to doc the \u0026lt;next-hop, mac\u0026gt; pair mapping for 30 secs in this lab, with this mapping, the next time sending to the same ip would not send ARP message again.\u003c/p\u003e","title":"cs144-lab5"},{"content":"Glue of CS144TCPSocket I will illustrate the glue for using CS144TCPSocket in one image. From the picture, we know that it\u0026rsquo;s our job to implement TCP/IP in user layer in this class. But how do our packets of network send to other computers through the internet ? The answer is to use tun/tap device under the linux kernel. The tun/tap device is kinda like a software net-card which tun device gives you raw IP packet and tap device gives you raw MAC dataframe. And follow the instructions of the tun.sh, setting the iptables to route makes our packet to go elsewhere.\nLet\u0026rsquo;s see what the tun.sh done in this lab.\ntun.sh The most important part of tun.sh is to create a tun/tap device and set the iproute tables. The snippet of the code is shown below.\nTUN_IP_PREFIX=169.254 local TUNNUM=\u0026#34;$1\u0026#34; TUNDEV=\u0026#34;tun$1\u0026#34; ip tuntap add mode tun user \u0026#34;${SUDO_USER}\u0026#34; name \u0026#34;${TUNDEV}\u0026#34; ip addr add \u0026#34;${TUN_IP_PREFIX}.${TUNNUM}.1/24\u0026#34; dev \u0026#34;${TUNDEV}\u0026#34; ip link set dev \u0026#34;${TUNDEV}\u0026#34; up ip route change \u0026#34;${TUN_IP_PREFIX}.${TUNNUM}.0/24\u0026#34; dev \u0026#34;${TUNDEV}\u0026#34; rto_min 10ms # Apply NAT (masquerading) only to traffic from CS144\u0026#39;s network devices iptables -t nat -A PREROUTING -s ${TUN_IP_PREFIX}.${TUNNUM}.0/24 -j CONNMARK --set-mark ${TUNNUM} iptables -t nat -A POSTROUTING -j MASQUERADE -m connmark --mark ${TUNNUM} echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward ubuntu:~$./tun.sh start 144 And I substitue this command to make it clear to see. Here is the translated snippet.\nip tuntap add mode tun user zyy name tun144 ip addr add 169.254.144.1/24 dev tun144 ip link set dev tun144 up ip route change 169.254.144.0/24 dev tun144 rto_min 10ms # Apply NAT (masquerading) only to traffic from CS144\u0026#39;s network devices iptables -t nat -A PREROUTING -s 169.254.144.0/24 -j CONNMARK --set-mark 144 iptables -t nat -A POSTROUTING -j MASQUERADE -m connmark --mark 144 echo 1 \u0026gt; /proc/sys/net/ipv4/ip_forward From the manual, we can bind an IP address to tun device. After binding, the network address is 169.254.144.0/24 which has 24bits subnet-mask. also, the broadcast address is 169.254.144.255/24 ,169.254.144.1/24 host address Note:default getway, set all host bit to 1 except the last bit. 169.254.144.254/24 default getway\nroute table show $ip route show default via 10.198.255.254 dev wlp1s0 proto dhcp metric 600 10.198.0.0/16 dev wlp1s0 proto kernel scope link src 10.198.129.197 metric 600 169.254.0.0/16 dev virbr0 scope link metric 1000 linkdown 169.254.144.0/24 dev tun144 scope link linkdown rto_min lock 10ms 169.254.144.0/24 dev tun144 proto kernel scope link src 169.254.144.1 linkdown 169.254.145.0/24 dev tun145 scope link linkdown rto_min lock 10ms 192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 linkdown $route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 10.198.255.254 0.0.0.0 UG 600 0 0 wlp1s0 10.198.0.0 0.0.0.0 255.255.0.0 U 600 0 0 wlp1s0 169.254.0.0 0.0.0.0 255.255.0.0 U 1000 0 0 virbr0 169.254.144.0 0.0.0.0 255.255.255.0 U 0 0 0 tun144 169.254.144.0 0.0.0.0 255.255.255.0 U 0 0 0 tun144 169.254.145.0 0.0.0.0 255.255.255.0 U 0 0 0 tun145 192.168.122.0 0.0.0.0 255.255.255.0 U 0 0 0 virbr0 From the iproute tables, we know 169.254.144.0/24 network address can be routed to elsewhere catching the default getway.\nNAT (Network Address Translation) zyy@ubuntu:~$ sudo iptables -t nat -L Chain PREROUTING (policy ACCEPT) target prot opt source destination CONNMARK all -- 169.254.144.0/24 anywhere CONNMARK set 0x90 Chain INPUT (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination Chain POSTROUTING (policy ACCEPT) target prot opt source destination LIBVIRT_PRT all -- anywhere anywhere MASQUERADE all -- anywhere anywhere connmark match 0x90 Chain LIBVIRT_PRT (1 references) target prot opt source destination RETURN all -- 192.168.122.0/24 base-address.mcast.net/24 RETURN all -- 192.168.122.0/24 255.255.255.255 MASQUERADE tcp -- 192.168.122.0/24 !192.168.122.0/24 masq ports: 1024-65535 MASQUERADE udp -- 192.168.122.0/24 !192.168.122.0/24 masq ports: 1024-65535 MASQUERADE all -- 192.168.122.0/24 !192.168.122.0/24 In the CS144Lab4, webget app binds an ip-address of 169.254.144.9, which belongs to tun144 ip network.\nmultiplexer_config.source = { \u0026#34;169.254.144.9\u0026#34;, std::to_string( uint16_t( std::random_device()() ) ) }; As we can see the iptables above, let\u0026rsquo;s illustrate the meaning of it by picture. If the source is in 169.254.144.0/24 network address, it will be set as mark 0x90 using masquerade target to route to elsewhere. And when the packet is coming, the kernel will choose to route to write application. That\u0026rsquo;s the lab4 routing strategy.\nAnalyse Data I collected for about 5 hours of data from 20250312 9:00:00 to 20250312 14:19:00. And I write a python script file to analyse the data to answer the 10 questions.\nquestion 1: echo_reply_rate loss : 115 dup : 41 echo_receive_rate : 0.9987992440458167\nquestion 2: longest concecutive max_consecutive : 8309\nquestion 3: longest missing concecutive max_missing : 8\nquestion 4: independent or correlated N+1_reply_N_missing: 0.0006690501578540217 N+1_reply_N_reply : 0.999330949842146\nFrom the result, we can see that it\u0026rsquo;s not idependent.\nquestion 5/6: get minimum and maximum RTT min RTT : 20.2 max RTT : 495\nquestion 7: Make a graph of the RTT as a function of time. Label the x-axis with the actual time of day (covering the 2+-hour period), and the y-axis should be the number of milliseconds of RTT. question8: Make a histogram or Cumulative Distribution Function of the distribution of RTTs observed. What rough shape is the distribution? question9: make a graph of the correlation between “RTT of ping #N” and “RTT of ping #N+1”. The x-axis should be the number of milliseconds from the first RTT, and the y-axis should be the number of milliseconds from the second RTT. How correlated is the RTT over time? I see but not clear that if this time RTT is large, maybe the second is small.\ncs144 note :: scope operator which I haven\u0026rsquo;t noticed before ::close function when in function close\nvoid FileDescriptor::FDWrapper::close() { CheckSystemCall( \u0026#34;close\u0026#34;, ::close( fd_ ) ); eof_ = closed_ = true; } ","permalink":"http://localhost:1313/posts/cs144/lab4/","summary":"\u003ch2 id=\"glue-of-cs144tcpsocket\"\u003eGlue of CS144TCPSocket\u003c/h2\u003e\n\u003cp\u003eI will illustrate the glue for using CS144TCPSocket in one image.\n\u003cimg loading=\"lazy\" src=\"/cs144/images/lab4_cs144_framework.png\"\u003e\nFrom the picture, we know that it\u0026rsquo;s our job to implement TCP/IP in user layer in this class. But how do our packets of network send to other computers through the internet ? The answer is to use tun/tap device under the linux kernel. The tun/tap device is kinda like a software net-card which tun device gives you raw IP packet and tap device gives you raw MAC dataframe. And follow the instructions of the tun.sh, setting the iptables to route makes our packet to go elsewhere.\u003c/p\u003e","title":"cs144-lab4"},{"content":"TCP Sender Class TCP Sender Responsibility,\n• Keep track of the receiver’s window (receiving incoming TCPReceiverMessages with their acknos and window sizes) • Fill the window when possible, by reading from the ByteStream, creating new TCP segments (including SYN and FIN flags if needed), and sending them. The sender should keep sending segments until either the window is full or the outbound ByteStream has nothing more to send. while loop • Keep track of which segments have been sent but not yet acknowledged by the receiver— we call these “outstanding” segments . outstanding segments • Re-send outstanding segments if enough time passes since they were sent, and they haven’t been acknowledged yet. timer class design\nNotes to be reminded of.\nwhen started, we see window size of the peer is 1, so we can just send SYN bit. tick method, when it was called, it proves that how many time passed, we don\u0026rsquo;t have to use clock or time function when received a ackno, how to compare (Wrap32) Basic implementation of tcp sender class\npush method first , we need to keep track of the window size of the TCPreceivermessage, use member variable. The basic idea of the method is to fill the window as possible. In here, we need to judge the ByteStream bytes_buffered , TCPconfig:MAX_PAYLOAD_SIZE, and the window size. Note: the TCPconfig:MAX_PAYLOAD_SIZE is only used for payload.\nWhen there is no message received at all, we just need to send SYN bit only. And if the message is comming, we need to fill the window as soon as possible. After that, add FIN bit in the end. The FIN bit is sometimes nusty when i implement this function. I use a close_state to indicate the FIN state, if the FIN state is sent, we see the connection is closed.\nWhen the window size is zero, we need to transmit one bit to the peer.\nI use list to keep track of the outstanding segments, when each segment is sent, we add it into the list. Using list, we can iterate easily.\nreceive method Each time , we received a TCPReceivermessage, we have to compare the ackno (absolute seqno greater than). But the Wrap32 will wrap around sometimes, so we just use operator== to compare. In the list, operator== matches it will return the iterator, then we use erase to remove it. Actually we have to do some arithematic to solve it, but it doesn\u0026rsquo;t matter.\nBesides, we are supposed to update the this-\u0026gt;recv_message_ which tracks the window size and wind_zero attribute. It\u0026rsquo;s quite important, so we have to do it.\nmake_empty_message Actually i don\u0026rsquo;t fully know why to implement this function, but What i know is that set the right seqno will make it easy. So we need an another var to keep track of the bytes_len transmitted.\ntick The tick function is really nusty for me, at first, we have the RTO initial value, when the tick is called , it says that how many times passed, if the time expired which means the passed time is greater than initial RTO, we have to resend the lowest seqno, and check the window_size to decide whether we should double the RTO or not, last but not least add the consecutive_transmissions for one.\nI implemented a timer class to do it, when to start the timer, and when to reset. Each time we push a valid segment we need to start the timer. And each time we recv an ackno, we should decide whether to reset or not.\nBug Advice when use STL library, check the empty first will minus the time you debug. When a ADDRESS_SNIFFER came out in the debug, you should consider if we forget checking the STL library before operating the container.\nCorner Cases There are many corner cases to remind of, but i don\u0026rsquo;t wanna metion in this blog post. Finally after great efforts, I finally succeeded.\n","permalink":"http://localhost:1313/posts/cs144/lab3/","summary":"\u003ch2 id=\"tcp-sender-class\"\u003eTCP Sender Class\u003c/h2\u003e\n\u003cp\u003eTCP  Sender Responsibility,\u003c/p\u003e\n\u003cp\u003e• Keep track of the receiver’s window (receiving incoming TCPReceiverMessages with\ntheir acknos and window sizes)\n• Fill the window when possible, by reading from the ByteStream, creating new TCP\nsegments (including SYN and FIN flags if needed), and sending them. The sender should\nkeep sending segments until either the window is full or the outbound ByteStream has\nnothing more to send. \u003cstrong\u003ewhile loop\u003c/strong\u003e\n• Keep track of which segments have been sent but not yet acknowledged by the receiver—\nwe call these “outstanding” segments . \u003cstrong\u003eoutstanding segments\u003c/strong\u003e\n• Re-send outstanding segments if enough time passes since they were sent, and they\nhaven’t been acknowledged yet. \u003cstrong\u003etimer class design\u003c/strong\u003e\u003c/p\u003e","title":"cs144-lab3"},{"content":"Outline of TCPreceiver From the lab0, and lab1 we have implemented the ByteStream and Reassembler, in this lab2, I am gonna implement TCPreceiver.\nFirst of all, we have to illustrate , in TCP (transmition control protocol), there may be many cases of the packets sent by the tcp peer of sender(versus the contrary). For example, there may be lost, altered, reordered, duplicated. And the TCP protocol was designed to handle these cases , so did I.\nreordered (out-of-order) or duplicated We can use index(seqno) to avoid this case, just like we analysed in lab1 the checking conditions of reassembler . For example,\nString \u0026#34;abcdef\u0026#34; push(\u0026#34;ab\u0026#34;) push(\u0026#34;ab\u0026#34;, index:0) push(\u0026#34;ab\u0026#34;) push(\u0026#34;ab\u0026#34;, index:0) push(\u0026#34;abcd\u0026#34;) -----------\u0026gt;push(\u0026#34;abcd\u0026#34;, index:0) push(\u0026#34;f\u0026#34;) push(\u0026#34;f\u0026#34;, index:5) push(\u0026#34;e\u0026#34;) push(\u0026#34;e\u0026#34;, index:4) altered As we all know, the stack of service abstraction is like,\nshort gets(DNS, DHCP)-\u0026gt;User datagrams-\u0026gt;Internet Datagrams Byte Stream(TCP) -\u0026gt;User datagrams -\u0026gt;Internet Datagrams \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-Web requests/responses(HTTP)-\u0026gt;Byte Stream \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;Youtube/wikipedia-\u0026gt; Web requests/responses \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-Email sending(SMTP)-\u0026gt;Byte Stream \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-Email receiving(IMTP)-\u0026gt;Byte Stream In the OSI model or industrial network model, the TCP will use IP protocol to send message or receive, and the IP has a checksum for check-up when the packets receive, it will drop it off if the packets are not right enough. So we the bytestream altered, the IP protocol will help us to drop it and handle this case.\nmissing or lost Like UDP, we can\u0026rsquo;t retransmit the message over and over again until we got the answer. So we have to use another method to handle this case. Acknolegement.\nByte String \u0026#34;A B C D E F G FIN\u0026#34; FIN indicates end of the string. Sender: Receiver: \u0026#34;A index:0\u0026#34; \u0026#34;B index:1\u0026#34; \u0026#34;C index:2\u0026#34; \u0026#34;D index:3\u0026#34; missing in the trip \u0026#34;E index:4\u0026#34; \u0026#34;F index:5\u0026#34; \u0026#34;G index:6\u0026#34; \u0026#34;FIN index:7\u0026#34; {ack:3} we assume that, the network area of sender is fast than receiver. That is why sender sends all messages before receiver receives. The receiver gives ack 3 means that, index 0 1 2 are received in the stream, next we need index 3. Note, we have to give FIN a number, when the ack 8 means we received FIN which can be an notion for the sender that it\u0026rsquo;s time to close the connection. However, is it enough? TCP is a flow-control protocol, the practical recv message is \u0026lt;ackno: \u0026lt;\u0026gt;, window_size: \u0026lt;\u0026gt; \u0026gt; which tells the sender the size of slide-window. In some situations, the window-size is far more meaningful.\nImplemention of Class In this lab2, the outline of the TCP receiver is like, Note: rule of TCP reply to any nonempty message.(which i haven\u0026rsquo;t noticed that until i implented the class of tcp receiver).\nend of stream And if the a sender has ended the stream, maybe the incoming bytes has not received yet. So the peer of the sender of TCP may not be closed. But at the same time, another connection has built used the same port number of the sender, and the last peer of sender will send the last packet, it will casue conflit with the new built sender.\nTo handle this we use a random big number as start of ISN (initial sequence number) + SYN to indicates the seqno, which can diminish the conflits. But in RFC of TCP header, the seqno is 32 bit, as the seqno grows it will wrap around to zero, so we have to do some arithemtics to handle this meric.\nNote: the first seqno is to SYN, and the last seqno is FIN. So we should acknolege each of them.\nThree-way-handshake without SYN and seqno: - I: {{first_index=0, data=”abcdef”, FIN=true}, {next_needed=0, window_size=1000}} - Peer: {{first_index=0, data=””, FIN=true}, {next_needed=7, window_size=1000}} - I: {{first_index=7, data=””, FIN=false}, {next_needed=1, window_size=1000}} no end of the stream, and the peer mistakes that the sender need to bytes from it. the next_needed sometimes will misunderstand the peer I think. with SYN: - I: {{seqno=12340, SYN=true, data=”abcdef”, FIN=true}, {What should this be? (before seeing 9999 from the Peer)}} - Peer: {{seqno=9999, SYN=true, data=””, FIN=true}, {next_needed=12348, window_size=1000}} - I: {{next_needed=10001, window size =1000}} That\u0026#39;s why we need a state ack to inform the peer of direction of bytestream. upgrade ACK \u0026lt;ACK flag, ackno\u0026gt;: - I: {{seqno=12340, SYN=true, data=”abcdef”, FIN=true}, {ACK=false, ackno={missing}, window_size=1000}} (SYN) - Peer: {{seqno=9999, SYN=true, data=””, FIN=true}, {ACK=true, ackno=12348, window_size=1000}} (SYN+ACK) - I: {{ACK=true, ackno=10001, window size =1000}} (ACK) This is three way handshake of TCP(SYN+SYN-ACK+ACK). Wrap and Unwrap From above, we know seqno is 32bit which will wrap around, for the UINT32_MAX is limited in network transmition. So we need to transfrom index from one to another.Here is the index table which represents the relationship between all of them. Wrap implemention like this.\n// ( SYN + n ) mod 2^32 return Wrap32 { zero_point + static_cast\u0026lt;uint32_t\u0026gt;(n)}; And Unwrap is kind of noying, that is because when given a number like 15, if the ISN is zero, the absolute index might be 15 , 15 + 2^32, 15 + 2^33, .etc. That\u0026rsquo;s why we need another checkpoint index closest near it to help find out the right index.\nuint64_t Wrap32::unwrap( Wrap32 zero_point, uint64_t checkpoint ) const { // SYN: 2^32 -2 this-\u0026gt;raw_value_; // seqno 2 // absolute seqno 2^32 + 4 uint32_t off = this-\u0026gt;raw_value_ - zero_point.raw_value_; if(this-\u0026gt;operator==(zero_point)){ // 0 , 2^32 , 2^33 .etc // [(checkpoint \u0026gt;\u0026gt; 32 \u0026lt;\u0026lt; 32 ) , (checkpoint \u0026gt;\u0026gt; 32 + 1) \u0026lt;\u0026lt; 32] // checkpoint \u0026gt;\u0026gt; 31 bool last = checkpoint \u0026amp; 0x0000000080000000; return (1UL \u0026lt;\u0026lt; 32) * ((checkpoint \u0026gt;\u0026gt; 32) + last); }else{ if(checkpoint \u0026lt;= off) return off; bool last = ( checkpoint - off )\u0026amp; 0x0000000080000000; return (1UL \u0026lt;\u0026lt; 32) * (((checkpoint - off) \u0026gt;\u0026gt; 32 ) + last)+ off; } } seqno equals to zero_point(ISN) This condition is simple, because it is not 0, or 2^32, or multiples of 2^32 which is near to checkpoint. And the way to get the nearest index is to find checkpoint is above or below the middle of the two.\n|--------|------------------| 2^(32+n-1) checkpoint 2^(32+n) we use checkpoint\u0026gt;\u0026gt;31 maybe 0x11 that\u0026#39;s above middle or 0x10, that\u0026#39;s below middle. use 31 not 32 to indicates the above or below middle which is helpful.(I dbg the tests finding that connection). seqno not equals to zero_point(ISN) we subtract an offset and still use the method above. And if you say off is minus zero, yes that\u0026rsquo;s true, and the unsigned will wrap it to plus value. Note: the minimum is off if the checkpoint is less than off. TCP Receiver Class keep track of start I use a class private var to track it, when it is true to insert substrings into the reassembler.\nindex calculate absolute index and real payload index in assembler.\n// Push any Data into the Reassembler uint64_t seqno = message.seqno.unwrap(this-\u0026gt;isn, this-\u0026gt;reassembler().unassembled_index()); // insert index starts from zero and pointed by payload this-\u0026gt;reassembler_.insert(message.SYN + seqno - 1, message.payload, message.FIN); send message Rule: TCP will reply any nonempty message. and we need to check whether the state_s is true or false to indicate the ack flag, and ackno is next_indexed(which is offered by reassembler ). RST state need to be designed when the bytestream has an error(the ByteStream has had this api provided).\nTCPReceiverMessage TCPReceiver::send() const { uint64_t win_size = this-\u0026gt;writer().available_capacity(); tcp_m.window_size = win_size \u0026gt;= UINT16_MAX ? UINT16_MAX : win_size; // to avoid overflow // unassembled_index + 1 (SYN must accept it) + FIN(may be not ending state so we use function of reassemble_connect_state to represent it) tcp_m.ackno = state_s ? ack.wrap(this-\u0026gt;reassembler_.unassembled_index() + 1 + this-\u0026gt;reassembler().reassemble_connect_state(), this-\u0026gt;isn) : std::optional\u0026lt;Wrap32\u0026gt;{}; tcp_m.RST = this-\u0026gt;reader().has_error(); return tcp_m; } Last but not least, Window size is 16 bits, when the capacity of bytestream is up to or above this limit, we must do some check to avoid this overflow when assignment.\nFinally, successfully passed the tests. ","permalink":"http://localhost:1313/posts/cs144/lab2/","summary":"\u003ch2 id=\"outline-of-tcpreceiver\"\u003eOutline of TCPreceiver\u003c/h2\u003e\n\u003cp\u003eFrom the lab0, and lab1 we have implemented the ByteStream and Reassembler, in this lab2, I am gonna implement TCPreceiver.\u003c/p\u003e\n\u003cp\u003eFirst of all, we have to illustrate , in TCP (transmition control protocol), there may be many cases of the packets sent by the tcp peer of sender(versus the contrary). For example, there may be lost, altered, reordered, duplicated. And the TCP protocol was designed to handle these cases , so did I.\u003c/p\u003e","title":"cs144-lab2"},{"content":"Overview Course Learn operations idempotency meaning:\nIdempotency is a property of certain operations or API requests that ensures performing the operation multiple times yields the same result as if it were executed only once. (GET PUT) And the result we expect is result form not result value.\nA non-idempotent operation, on the other hand, changes the state with each execution, meaning that subsequent calls with the same input can yield different results. This is crucial to recognize because it can lead to unintended side effects when such operations are repeated. (POST)\nshort packets data can be\nlost reorder alter duplicate line of code From the startup code, i used almost 122 lines of code to design ByteStream in lab0 which is larger than TA in class - 82 lines of code.\nhow to run this scripts ?\n$ sudo apt install slocount $ ./scripts/lines-of-code ; in mindow directory ByteStream: 122 lines of code Reassembler: 26 lines of code $ ByteStream: 82 lines of code Reassembler: 26 lines of code TCP Receiver In this assignment , what you\u0026rsquo;re gonna do is to rearrage the bytestream form unreliable to reliable and then to offer to the Socket that can be read by the web-application like webget, etc.\nwhy do this ?\nTCP robustness against reordering and duplication comes form its ability to stitch arbitrary excerpts of the byte stream back into the original stream. Implementing this in a discrete testable module will make handling incoming segments easier.\nIncoming Substring normal format \u0026#34;abcdefghaaa\u0026#34; {index: 0, \u0026#34;abcd\u0026#34;} {index: 4, \u0026#34;efg\u0026#34;} {index: 7, \u0026#34;ha\u0026#34;} {index: 9, \u0026#34;aa\u0026#34;, last_string: ture} or \u0026#34;zyyll\u0026#34; {index: 0, \u0026#34;z\u0026#34;} {index: 0, \u0026#34;zyy\u0026#34;} {index: 3, \u0026#34;ll\u0026#34;, last_string: true} .etc. your Reassember module should handle many corner cases like lost, duplicate, altered, and reordered.\nOutline of Reassember Class The whole incoming substring construct format is like this. code procedure step 1. check whether the incoming substring can be put into Bytestream or not? From the picture, we know that the incoming string\u0026rsquo;s index should not lie beyond first unaccepted index. And, similarly an duplicated substring which doesn\u0026rsquo;t exceed the first_unassembled_index is not allowed to put into the bytestream module. So the conditions are like this below.\n// Step1. discard message for duplicate and lie beyond size uint64_t avi = this-\u0026gt;writer().available_capacity(); uint64_t pos = 0; uint64_t cnt = 0; if(first_index \u0026gt; next_index + avi) return; // lie beyond if(first_index + data.size() \u0026lt;= next_index){ if(is_last_substring) // corner case like emtpy string \u0026#34;\u0026#34; and close this-\u0026gt;output_.writer().close(); return; // duplicate } if(first_index + data.size() \u0026gt; next_index + avi){ // not fully lie beyond but we need to doc the state of temp // update the beyond_ if(is_last_substring){ // need to check beyond_index = first_index + data.size(); nclose_state = true; } // |-----| // |-----| // [pos, cnt] cnt = first_index + data.size() - next_index -avi; pos = data.size() - cnt; data.erase(pos, cnt); } step 2. substrings can be put or assembled the incoming substring can be like in the picture below. if the substring covers the next_index, we have to put into the Bytestream, if not we have to put into the reassember internal storage. To simplify the reassembler class, i chose std::unordered_map\u0026lt;uint64_t, std::stirng\u0026gt; as the internal storage for reassember, that\u0026rsquo;s because we can find and iterate it fast.\n// two conditions like 1). repeat send but large enough , then need to be merged // 2). not sequenced needed to be put in map_ , then need to be merged if(first_index \u0026lt;= next_index){ // |-----| // |-----| pos = 0; cnt = next_index - first_index; data.erase(pos, cnt); this-\u0026gt;output_.writer().push(data); // update next_index; next_index += data.size(); // then check if need to merge and push auto it = find_next_assembly(next_index); while(it != map_.end() \u0026amp;\u0026amp; map_.size() \u0026gt; 0){ pos = 0; cnt = next_index - it-\u0026gt;first; it-\u0026gt;second.erase(pos, cnt); this-\u0026gt;output_.writer().push(it-\u0026gt;second); next_index += it-\u0026gt;second.size(); map_.erase(it); it = find_next_assembly(next_index); } // |-----| pushed // |---| pending // do some clear this-\u0026gt;unassmbly_clear(next_index); } When I put the substring in the bytestream module, we have to think over whether there are other unassembled strings can be merged. The function find_next_assembly is the way to find one, I choose while loop structure to merge that.\nLast but not least, I need do some clear in case that while-loop finds nothing to merge but need to discard like\n// |-----| pushed // |---| pending // do some clear step3, string that put into the internal storage of reassembler Well, strings that put into the map_ might also be merged in some cases, like the string cover the one in map_, or the string can splice with another one in the map_. there are many cases we can think of, but only two conditions can handle these cases. So we need to check which one it is , and if not just insert into the internal storage.\nHere are the two conditions. And the code implementation is just like do the left check loop until merged, after that do the same thing as the right loop check. And if the program runs out of the two loop, we can figure it out that this string need not be merged and just put into the map_.\nvoid Reassembler::merge_unassembly_map(uint64_t index, std::string data){ // Condition 1. find left auto it_left = find_merge_left(map_, index, data); uint64_t cnt = 0; uint64_t pos = 0; uint64_t i = 0; while(it_left != map_.end()){ if(index + data.size() \u0026gt;= it_left-\u0026gt;first + it_left-\u0026gt;second.size()){ map_.erase(it_left); map_.insert({index, data}); }else{ if(index == it_left-\u0026gt;first){ //do nothing break; }else{ cnt = it_left-\u0026gt;first + it_left-\u0026gt;second.size() - index - data.size(); pos = it_left-\u0026gt;second.size() - cnt; for(i = 0; i \u0026lt; cnt; i++) data.push_back(it_left-\u0026gt;second[pos + i]); map_.erase(it_left); map_.insert({index, data}); } } it_left = find_merge_left(map_, index, data); } auto it_right = find_merge_right(map_, index, data); while(it_right != map_.end()){ if(index + data.size() \u0026lt;= it_right-\u0026gt;first + it_right-\u0026gt;second.size()){ // do nothing return; }else{ cnt = index + data.size() - it_right-\u0026gt;first - it_right-\u0026gt;second.size(); pos = data.size() - cnt; for(i = 0; i \u0026lt; cnt; i++){ it_right-\u0026gt;second.push_back(data[pos+i]); } // to avoid the index is in the map if(index != it_right-\u0026gt;first){ it_right = map_.find(index); if(it_right != map_.end()) map_.erase(it_right); } return; } it_right = find_merge_right(map_, index, data); } // map_.insert({index, data}); return; } corner case \u0026ldquo;bz\u0026rdquo;, index 1, is last string ture; capacity = 1\nthis case demostrates that, the last string has come first. But we don\u0026rsquo;t have too much room to put into the internal storage. So we need to do some check and handle this case. In my mind, I choose to document the beyond_index it finally reaches. So when everythings works fine, i have to check if the beyond_index equals the next_index or not in the last.\nif(is_last_substring){ close_state = true; } if(!nclose_state){ beyond_index = next_index; } if(close_state \u0026amp;\u0026amp; map_.size() == 0 \u0026amp;\u0026amp; beyond_index == next_index){ this-\u0026gt;output_.writer().close(); } return; line of code ./scripts/lines-of-code ByteStream: 122 lines of code Reassembler: 176 lines of code Lastly, i passed the tests, but the codes i wrote are a little bit clumsy. I will implement and upgrade this class module in the future to make it easy to use.\n","permalink":"http://localhost:1313/posts/cs144/lab1/","summary":"\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003ch3 id=\"course-learn\"\u003eCourse Learn\u003c/h3\u003e\n\u003cp\u003eoperations idempotency meaning:\u003c/p\u003e\n\u003cp\u003eIdempotency is a property of certain operations or API requests that ensures performing the operation multiple times yields the same result as if it were executed only once. (GET PUT)\nAnd the result we expect is \u003cstrong\u003eresult form\u003c/strong\u003e not \u003cstrong\u003eresult value\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA non-idempotent operation, on the other hand, changes the state with each execution, meaning that subsequent calls with the same input can yield different results. This is crucial to recognize because it can lead to unintended side effects when such operations are repeated. (POST)\u003c/p\u003e","title":"cs144-lab1"},{"content":"1 Set up Linux environment ubuntu 22.04 g++ 11.4 packages required $ sudo apt update \u0026amp;\u0026amp; sudo apt install git cmake gdb build-essential clang \\ clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark 2 Networking by hand networking abstraction \u0026mdash;reliable bidirectional byte stream\n2.1 Fetch a Web Page steps web server address using telnet telnet cs144.keithw.org http to open a reliable byte stream between two computers. First, Type GET /hello HTTP/1.1 `Enter` the Enter is very important Second, Type Host: cs144.keithw.org `Enter` Third, Type Connection: close `Enter`` Finally, Type `Enter` explanation \u0026mdash;\u0026mdash;\u0026ndash; http://host/path\nGET tells the path part of the URL Host tells the host part of the URL close tells the server you finished the request the last `Enter`tells the server you are done with the HTTP request After that the result is as such. 2.2 Send yourself an email send an email massage using a reliable byte stream to a service running on another computer I use 163-netease email to do this job for I am not standford student.These steps are introduced as follows:\ngo to the setting of the 163-email to enable smtp server Then using telnet to construct a connection between two computers `telnet smtp.163.com smtp` or `telnet smtp.163.com 25` where port `25` is the smtp server port number Type `HELO hello.victor` `Enter` it will echo `250 OK` the response code number starts with 2xx or 3xx is great to indicate connection is right! But when the response code number is 5xx, it tells you that something was wrong. Type `EHLO hello.victor` it will print it out something you need to do to authentication. After that, you need to login in by type `AUTH LOGIN` , when you do that, you have to type base64 coded you user name and vertification code.base64 converter This page will help you to do so, last but no least you have to set you own vertification code in your 163-email website. When authentication is successfully, you are allowed to send an email. as you can see from the picture, after authentication, we can send email from byte stream by typing `MAIL FROM:` and `RCPT TO:`, don\u0026rsquo;t forget to add an `\u0026lt;\u0026gt;`around your email address. When you type Data, you have to leave a blank line at the end of the headers. When finished the body, type `Enter`to end this edit. With all things done, type `quit` to end the conversation with the email.\ntelnet: a client that makes outgoing connection with programs running on other computers. Let\u0026rsquo;s to be a simple server, which is kind of program that waits around for clients to connect it.\n2.3 Listening and connecting The netcat command `v` to produce more verbose output, and `-l` to listening a port and `-p` to designate port number 9090, the telnet to connect this server, which localhost indicates the same ip address shared each other. This picture indicates this communication.\n3 Writing a network program using an OS stream socket we are gonna to use the feature provided by operating system (Linux) that the ability to create a reliable bidirectional byte stream between two commputers.\u0026mdash;- Stream Socket\n3.1 webget TCPSocket Class - in mindow project, the socket class lib is wrapped around using C++ and can be called from C code.\nTCPSocket Class inheritance relationship\nthis image shows up the inheritance relationship.\nFileDescriptor Class\ncopy/move constructor and assignment Copy Constructor Ref Detail\nA copy constructor is a constructor which can be called with an argument of the same class type and copies the content of the argument without mutating the argument.\nargument list must satisfy all following conditions\ngiven the class type T, the argument list must be a reference of T it will be T\u0026amp;, const T \u0026amp;, volatile T\u0026amp;, const volatile T\u0026amp; note: it can have multiple args but at least ref of class in it.\nWhen copy constructor is called?\ninitialization T a = b; T a(b); where b is class of T. function arg passing void f(T a). function return value, which has no move constructor. T f(){ return a} Copy Assignment Ref Detail\nargument list must satisfy all following conditions\ngiven the class type T, the argument list must be a reference of T and T it will be T, T\u0026amp;, const T \u0026amp;, volatile T\u0026amp;, const volatile T\u0026amp; note: it must have one argument.\nWhen to call the copy assignment?\nThe copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression.\nlike: f1 = f2; operator= is selected when overload resoluting.\nMove Constructor Ref Detail\nargument list must satisfy all following conditions\ngiven the class type T, the argument list must be \u0026amp;\u0026amp; like. it will be T\u0026amp;\u0026amp;, const T \u0026amp;\u0026amp;, volatile T\u0026amp;\u0026amp;, const volatile T\u0026amp;\u0026amp;. When to call the move constructor?\ninitialization like T a = std::move(b) argument passing f(std::move(a) return type like return a T f() Move Assignment Ref Detail\nlike a = std::move(a2) The copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression.\n// An FDWrapper cannot be copied or moved FDWrapper( const FDWrapper\u0026amp; other ) = delete; // copy constructor FDWrapper\u0026amp; operator=( const FDWrapper\u0026amp; other ) = delete; // copy assignment FDWrapper( FDWrapper\u0026amp;\u0026amp; other ) = delete; // move constructor FDWrapper\u0026amp; operator=( FDWrapper\u0026amp;\u0026amp; other ) = delete; // move assignment webget sequence the sequence of tcp connect is like this..\nconstruct TCPSocket\nconstruct Address\nconnect\nwrite buffer to get url page\nwait to read like string operation\nall these functions will call CheckSystemCall and then unix_error will call kernel api like socket connect and or so.\nclass unix_error : public tagged_error { public: explicit unix_error( const std::string_view s_attempt, const int s_errno = errno ) : tagged_error( std::system_category(), s_attempt, s_errno ) {} }; 3.2 byte stream In this section I will implement a pipe like byte stream, which a Writer puts data into the pipe and the Reader pops it.\nAfter reading the check0.pdf, I firstly choose string as a ring buffer.\ncompile error and run error\n$ cmake --build build --target check0 it will print out this message like that infinitely. AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL AddressSanitizer:DEADLYSIGNAL After that I search from StackOverflow, it turns out that the linux setting is not suitable for clang. The solution for this is\n$sudo sysctl vm.mmap_rhd_bits=28(check the value by sudo sysctl vm.mmap_rhd_bits) after reboot this change will disappear. And if I wanna pernament change this setting, I have to change the etc file of /etc/sysctl.conf add `vm.mmap_rhd_bits=28` in this file $sudo sysctl -p if not just reboot std::string_view\nThe std::string_view class I don\u0026rsquo;t fully understand, so I failed in peek tests. That is a ring buffer is wrapped around when start and end pointers are not equal, and string_view class needs a sequence char in memory. So i fail in the peek tests.\nAfter that, I switch to deque/queue. In this way, I passed 7 tests, but stuck in 8 peek tests, it says that heap buffer overflow when I didn\u0026rsquo;t use gdb in eshell. The reason why i got this error is still string_view needs a sequence capture char in memory. And deque/queue implementation is chunks of memory linked, each set of memory is in sequence but not all the items. I use gdb to prove that. From the picture, we can see that the deque has discontinuous memory address the same as queue, that\u0026rsquo;s why I get this error for several days to handle.\nThen I switched to list vector as my pipe container. Everything works great, except that string_view must constructs with continuous iterator, we all knew that linked-list has discontinous items when inset and remove.\nThe final approach to handle peek function is use another string whenever I push or pop from the pipe I always rearrange the pipe so that it is in sequential memory using copy method.\nvoid Writer::push( string data ) { // ........ // reflush the pipe_view after each push and pop if(pipe_e \u0026gt; pipe_s){ pipe_.copy(\u0026amp;pipe_view[0], pipe_.size(), pipe_s); }else{ pipe_.copy(\u0026amp;pipe_view[0], capacity_ - pipe_s, pipe_s); pipe_.copy(\u0026amp;pipe_view[capacity_ - pipe_s], pipe_e, 0); } } void Reader::pop( uint64_t len ) { // .... // reflush the pipe_view after each push and pop if(pipe_e \u0026gt; pipe_s){ pipe_.copy(\u0026amp;pipe_view[0], pipe_.size(), pipe_s); }else{ pipe_.copy(\u0026amp;pipe_view[0], capacity_ - pipe_s, pipe_s); pipe_.copy(\u0026amp;pipe_view[capacity_ - pipe_s], pipe_e, 0); } } and if I do some changes in Peek function it will cause compilation error like that.\nerror: invalid conversion from ‘const __gnu_cxx::__alloc_traits\u0026lt;std::allocator\u0026lt;char\u0026gt;, char\u0026gt;::value_type*’ {aka ‘const char*’} to ‘char*’ [-fpermissive] That is because Peek function is a const member function which has no right to change the member value.\nAfter adopting this way, I finally successfully passed the tests, though the speed is not so fast but i give in my efforts. There are a lot of efforts to take to make the code looks great and faster. I will do it in the future. ","permalink":"http://localhost:1313/posts/cs144/lab0/","summary":"\u003ch2 id=\"1-set-up-linux-environment\"\u003e1 Set up Linux environment\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eubuntu 22.04\u003c/li\u003e\n\u003cli\u003eg++ 11.4\u003c/li\u003e\n\u003cli\u003epackages required\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e $ sudo apt update \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo apt install git cmake gdb build-essential clang \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003eclang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"2-networking-by-hand\"\u003e2 Networking by hand\u003c/h2\u003e\n\u003cp\u003enetworking abstraction        \u0026mdash;reliable bidirectional byte stream\u003c/p\u003e\n\u003ch3 id=\"2-dot-1-fetch-a-web-page\"\u003e2.1 Fetch a Web Page\u003c/h3\u003e\n\u003ch4 id=\"steps\"\u003esteps\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://cs144.keithw.org/hello\"\u003eweb server address\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eusing telnet \u003cstrong\u003etelnet cs144.keithw.org http\u003c/strong\u003e to open a reliable byte stream between two computers.\u003c/li\u003e\n\u003cli\u003eFirst, Type \u003cstrong\u003eGET /hello HTTP/1.1\u003c/strong\u003e `Enter` the Enter is very important\u003c/li\u003e\n\u003cli\u003eSecond, Type \u003cstrong\u003eHost: cs144.keithw.org\u003c/strong\u003e `Enter`\u003c/li\u003e\n\u003cli\u003eThird, Type \u003cstrong\u003eConnection: close\u003c/strong\u003e `Enter``\u003c/li\u003e\n\u003cli\u003eFinally, Type `Enter`\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"explanation\"\u003eexplanation\u003c/h4\u003e\n\u003cp\u003e\u0026mdash;\u0026mdash;\u0026ndash; \u003cstrong\u003e\u003ca href=\"http://host/path\"\u003ehttp://host/path\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"cs144-lab0"}]